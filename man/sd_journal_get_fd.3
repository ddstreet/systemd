'\" t
.\"     Title: sd_journal_get_fd
.\"    Author: Lennart Poettering <lennart@poettering.net>
.\" Generator: DocBook XSL Stylesheets v1.77.1 <http://docbook.sf.net/>
.\"      Date: 03/07/2013
.\"    Manual: sd_journal_get_fd
.\"    Source: systemd
.\"  Language: English
.\"
.TH "SD_JOURNAL_GET_FD" "3" "" "systemd" "sd_journal_get_fd"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
sd_journal_get_fd, sd_journal_reliable_fd, sd_journal_process, sd_journal_wait, SD_JOURNAL_NOP, SD_JOURNAL_APPEND, SD_JOURNAL_INVALIDATE \- Journal change notification interface
.SH "SYNOPSIS"
.sp
.ft B
.nf
#include <systemd/sd\-journal\&.h>
.fi
.ft
.HP \w'int\ sd_journal_get_fd('u
.BI "int sd_journal_get_fd(sd_journal*\ " "j" ");"
.HP \w'int\ sd_journal_reliable_fd('u
.BI "int sd_journal_reliable_fd(sd_journal*\ " "j" ");"
.HP \w'int\ sd_journal_process('u
.BI "int sd_journal_process(sd_journal*\ " "j" ");"
.HP \w'int\ sd_journal_wait('u
.BI "int sd_journal_wait(sd_journal*\ " "j" ", uint64_t\ " "timeout_usec" ");"
.SH "DESCRIPTION"
.PP
\fBsd_journal_get_fd()\fR
returns a file descriptor that may be asynchronously polled in an external event loop and is signaled readable as soon as the journal changes, because new entries or files were added, rotation took place, or files have been deleted, and similar\&. The file descriptor is suitable for usage in
\fBpoll\fR(2)
where it will yield POLLIN on changes\&. The call takes one argument: the journal context object\&. Note that not all file systems are capable of generating the necessary events for wakeups from this file descriptor to be enirely reliable\&. In particular network files systems do not generate suitable file change events in all cases\&. In such a case an application should not rely alone on wake\-ups from this file descriptor but wake up and recheck the journal in regular time intervals, for example every 2s\&. To detect cases where this is necessary, use
\fBsd_journal_reliable_fd()\fR, below\&.
.PP
\fBsd_journal_reliable_fd()\fR
may be used to check whether the wakeup events from the file descriptor returned by
\fBsd_journal_get_fd\fR
are sufficient to track changes to the journal\&. If this call returns 0, it is necessary to regularly recheck for journal changes (suggestion: every 2s)\&. If this call returns a positive integer this is not necessary, and wakeups from the file descriptor returned by
\fBsd_journal_get_fd()\fR
are sufficient as only source for wake\-ups\&.
.PP
After each POLLIN wake\-up
\fBsd_journal_process()\fR
needs to be called to process events and reset the readable state of the file descriptor\&. This call will also indicate what kind of change has been detected (see below; note that spurious wake\-ups are possible)\&.
.PP
A synchronous alternative for using
\fBsd_journal_get_fd()\fR,
\fBsd_journal_reliable_fd()\fR
and
\fBsd_journal_process()\fR
is
\fBsd_journal_wait()\fR\&. It will synchronously wait until the journal gets changed, possibly using a 2s time\-out if this is necessary (see above)\&. In either way the maximum time this call sleeps may be controlled with the
\fItimeout_usec\fR
parameter\&. Pass
(uint64_t) \-1
to wait indefinitely\&. Internally this call simply combines
\fBsd_journal_get_fd()\fR,
\fBsd_journal_reliable_fd()\fR,
\fBpoll()\fR
and
\fBsd_journal_process()\fR
into one\&.
.SH "RETURN VALUE"
.PP
\fBsd_journal_get_fd()\fR
returns a valid file descriptor on success or a negative errno\-style error code\&.
.PP
\fBsd_journal_reliable_fd()\fR
returns a positive integer if the file descriptor returned by
\fBsd_journal_get_fd()\fR
is sufficient as sole wake\-up source for journal change events\&. Returns 0 if it is not sufficient and the journal needs to be checked manually in regular time intervals for changes\&. Returns a negative errno\-style error code on failure\&.
.PP
\fBsd_journal_process()\fR
and
\fBsd_journal_wait()\fR
return one of
SD_JOURNAL_NOP,
SD_JOURNAL_APPEND
or
SD_JOURNAL_INVALIDATE
on success or a negative errno\-style error code\&. If
SD_JOURNAL_NOP
is returned the journal didn\*(Aqt change since the last invocation\&. If
SD_JOURNAL_APPEND
is returned new entries have been appended to the end of the journal\&. If
SD_JOURNAL_INVALIDATE
journal files were added or removed (possibly due to rotation)\&. In the latter event live\-view UIs should probably refresh their entire display while in the case of
SD_JOURNAL_APPEND
it is sufficient to simply continue reading at the previous end of the journal\&.
.SH "NOTES"
.PP
The
\fBsd_journal_get_fd()\fR,
\fBsd_journal_reliable_fd()\fR,
\fBsd_journal_process()\fR
and
\fBsd_journal_wait()\fR
interfaces are available as shared library, which can be compiled and linked to with the
libsystemd\-journal
\fBpkg-config\fR(1)
file\&.
.SH "EXAMPLES"
.PP
Iterating through the journal, in a live view tracking all changes:
.sp
.if n \{\
.RS 4
.\}
.nf
#include <stdio\&.h>
#include <string\&.h>
#include <systemd/sd\-journal\&.h>

int main(int argc, char *argv[]) {
        int r;
        sd_journal *j;
        r = sd_journal_open(&j, SD_JOURNAL_LOCAL_ONLY);
        if (r < 0) {
                fprintf(stderr, "Failed to open journal: %s\en", strerror(\-r));
                return 1;
        }
        for (;;)  {
                const void *d;
                size_t l;
                r = sd_journal_next(j);
                if (r < 0) {
                        fprintf(stderr, "Failed to iterate to next entry: %s\en", strerror(\-r));
                        break;
                }
                if (r == 0) {
                        /* Reached the end, let\*(Aqs wait for changes, and try again */
                        r = sd_journal_wait(j, (uint64_t) \-1);
                        if (r < 0) {
                                fprintf(stderr, "Failed to wait for changes: %s\en", strerror(\-r));
                                break;
                        }
                        continue;
                }
                r = sd_journal_get_data(j, "MESSAGE", &d, &l);
                if (r < 0) {
                        fprintf(stderr, "Failed to read message field: %s\en", strerror(\-r));
                        continue;
                }
                printf("%\&.*s\en", (int) l, (const char*) d);
        }
        sd_journal_close(j);
        return 0;
}
.fi
.if n \{\
.RE
.\}
.PP
Waiting with
\fBpoll()\fR
(this example lacks all error checking for the sake of simplicity):
.sp
.if n \{\
.RS 4
.\}
.nf
#include <sys/poll\&.h>
#include <systemd/sd\-journal\&.h>

int wait_for_changes(sd_journal *j) {
        struct pollfd pollfd;
        pollfd\&.fd = sd_journal_get_fd(j);
        pollfd\&.events = POLLIN;
        poll(&pollfd, 1, sd_journal_reliable_fd(j) > 0 ? \-1 : 2000);
        return sd_journal_process(j);
}
                
.fi
.if n \{\
.RE
.\}
.SH "SEE ALSO"
.PP

\fBsystemd\fR(1),
\fBsd-journal\fR(3),
\fBsd_journal_open\fR(3),
\fBsd_journal_next\fR(3),
\fBpoll\fR(2)
