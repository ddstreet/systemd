<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>systemd.unit</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="refentry" title="systemd.unit"><a id="systemd.unit"/><div class="titlepage"/><div class="refnamediv"><h2>Name</h2><p>systemd.unit â€” systemd unit configuration files</p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><p><code class="filename">systemd.service</code>,
                <code class="filename">systemd.socket</code>,
                <code class="filename">systemd.device</code>,
                <code class="filename">systemd.mount</code>,
                <code class="filename">systemd.automount</code>,
                <code class="filename">systemd.swap</code>,
                <code class="filename">systemd.target</code>,
                <code class="filename">systemd.path</code>,
                <code class="filename">systemd.timer</code>,
                <code class="filename">systemd.snapshot</code></p></div><div class="refsect1" title="Description"><a id="id379069"/><h2>Description</h2><p>A unit configuration file encodes information
                about a service, a socket, a device, a mount point, an
                automount point, a swap file or partition, a start-up
                target, a file system path or a timer controlled and
                supervised by
                <span class="citerefentry"><span class="refentrytitle">systemd</span>(1)</span>. The
                syntax is inspired by <a class="ulink" href="http://standards.freedesktop.org/desktop-entry-spec/latest/">XDG
                Desktop Entry Specification</a> <code class="filename">.desktop</code> files, which are in turn
                inspired by Microsoft Windows
                <code class="filename">.ini</code> files.</p><p>This man pages lists the common configuration
                options of all the unit types. These options need to
                be configured in the [Unit] resp. [Install]
                section of the unit files.</p><p>In addition to the generic [Unit] and [Install]
                sections described here, each unit should have a
                type-specific section, e.g. [Service] for a service
                unit. See the respective man pages for more
                information.</p><p>Unit files may contain additional options on top
                of those listed here. If systemd encounters an unknown
                option it will write a warning log message but
                continue loading the unit. If an option is prefixed
                with <code class="option">X-</code> it is ignored completely by
                systemd. Applications may use this to include
                additional information in the unit files.</p><p>Boolean arguments used in unit files can be
                written in various formats. For positive settings the
                strings <code class="option">1</code>, <code class="option">yes</code>,
                <code class="option">true</code> and <code class="option">on</code> are
                equivalent. For negative settings the strings
                <code class="option">0</code>, <code class="option">no</code>,
                <code class="option">false</code> and <code class="option">off</code> are
                equivalent.</p><p>Time span values encoded in unit files can be
                written in various formats. A stand-alone number
                specifies a time in seconds. If suffixed with a time
                unit, the unit is honored. A concatenation of
                multiple values with units is supported, in which case
                the values are added up. Example: "50" refers to 50
                seconds; "2min 200ms" refers to 2 minutes plus 200
                milliseconds, i.e. 120200ms. The following time units
                are understood: s, min, h, d, w, ms, us.</p><p>Empty lines and lines starting with # or ; are
                ignored. This may be used for commenting. Lines ending
                in a backslash are concatenated with the following
                line while reading and the backslash is replaced by a
                space character. This may be used to wrap long lines.</p><p>If a line starts with <code class="option">.include</code>
                followed by a file name, the specified file will be
                read as if its contents were listed in place of the
                <code class="option">.include</code> directive.</p><p>Along with a unit file
                <code class="filename">foo.service</code> a directory
                <code class="filename">foo.service.wants/</code> may exist. All
                units symlinked from such a directory are implicitly
                added as dependencies of type
                <code class="varname">Wanted=</code> to the unit. This is useful
                to hook units into the start-up of other units,
                without having to modify their unit configuration
                files. For details about the semantics of
                <code class="varname">Wanted=</code> see below. The preferred
                way to create symlinks in the
                <code class="filename">.wants/</code> directory of a service is
                with the <span class="command"><strong>enable</strong></span> command of the
                <span class="citerefentry"><span class="refentrytitle">systemctl</span>(1)</span>
                tool which reads information from the [Install]
                section of unit files. (See below.) A similar
                functionality exists for <code class="varname">Requires=</code>
                type dependencies as well, the directory suffix is
                <code class="filename">.requires/</code> in this case.</p><p>Note that while systemd offers a flexible
                dependency system between units it is recommended to
                use this functionality only sparsely and instead rely
                on techniques such as bus-based or socket-based
                activation which makes dependencies implicit, which
                both results in a simpler and more flexible
                system.</p><p>Some unit names reflect paths existing in the
                file system name space. Example: a device unit
                <code class="filename">dev-sda.device</code> refers to a device
                with the device node <code class="filename">/dev/sda</code> in
                the file system namespace. If this applies a special
                way to escape the path name is used, so that the
                result is usable as part of a file name. Basically,
                given a path, "/" is replaced by "-", and all
                unprintable characters and the "-" are replaced by
                C-style "\x20" escapes. The root directory "/" is
                encoded as single dash, while otherwise the initial
                and ending "/" is removed from all paths during
                transformation. This escaping is reversible.</p><p>Optionally, units may be instantiated from a
                template file at runtime. This allows creation of
                multiple units from a single configuration file. If
                systemd looks for a unit configuration file it will
                first search for the literal unit name in the
                filesystem. If that yields no success and the unit
                name contains an @ character, systemd will look for a
                unit template that shares the same name but with the
                instance string (i.e. the part between the @ character
                and the suffix) removed. Example: if a service
                <code class="filename">getty@tty3.service</code> is requested
                and no file by that name is found, systemd will look
                for <code class="filename">getty@.service</code> and
                instantiate a service from that configuration file if
                it is found. To refer to the instance string from
                within the configuration file you may use the special
                <code class="literal">%i</code> specifier in many of the
                configuration options. Other specifiers that may be
                used are <code class="literal">%n</code>, <code class="literal">%N</code>,
                <code class="literal">%p</code>, <code class="literal">%P</code>,
                <code class="literal">%I</code> and <code class="literal">%f</code>, for
                the full unit name, the unescaped unit name, the
                prefix name, the unescaped prefix name, the unescaped
                instance name and the unescaped filename,
                respectively. The unescaped filename is either the
                unescaped instance name (if set) with / prepended (if
                necessary), or the prefix name similarly prepended
                with /. The prefix name here refers to the string
                before the @, i.e. "getty" in the example above, where
                "tty3" is the instance name.</p><p>If a unit file is empty (i.e. has the file size
                0) or is symlinked to <code class="filename">/dev/null</code>
                its configuration will not be loaded and it appears
                with a load state of <code class="literal">masked</code>, and
                cannot be activated. Use this as an effective way to
                fully disable a unit, making it impossible to start it
                even manually.</p><p>The unit file format is covered by the
                <a class="ulink" href="http://www.freedesktop.org/wiki/Software/systemd/InterfaceStabilityPromise">Interface
                Stability Promise</a>.</p></div><div class="refsect1" title="Options"><a id="id346795"/><h2>Options</h2><p>Unit file may include a [Unit] section, which
                carries generic information about the unit that is not
                dependent on the type of unit:</p><div class="variablelist"><dl><dt><span class="term"><code class="varname">Description=</code></span></dt><dd><p>A free-form string
                                describing the unit. This is intended
                                for use in UIs to show descriptive
                                information along with the unit
                                name.</p></dd><dt><span class="term"><code class="varname">Requires=</code></span></dt><dd><p>Configures requirement
                                dependencies on other units. If this
                                unit gets activated, the units listed
                                here will be activated as well. If one
                                of the other units gets deactivated or
                                its activation fails, this unit will
                                be deactivated. This option may be
                                specified more than once, in which
                                case requirement dependencies for all
                                listed names are created. Note that
                                requirement dependencies do not
                                influence the order in which services
                                are started or stopped. This has to be
                                configured independently with the
                                <code class="varname">After=</code> or
                                <code class="varname">Before=</code> options. If
                                a unit
                                <code class="filename">foo.service</code>
                                requires a unit
                                <code class="filename">bar.service</code> as
                                configured with
                                <code class="varname">Requires=</code> and no
                                ordering is configured with
                                <code class="varname">After=</code> or
                                <code class="varname">Before=</code>, then both
                                units will be started simultaneously
                                and without any delay between them if
                                <code class="filename">foo.service</code> is
                                activated. Often it is a better choice
                                to use <code class="varname">Wants=</code>
                                instead of
                                <code class="varname">Requires=</code> in order
                                to achieve a system that is more
                                robust when dealing with failing
                                services.</p></dd><dt><span class="term"><code class="varname">RequiresOverridable=</code></span></dt><dd><p>Similar to
                                <code class="varname">Requires=</code>.
                                Dependencies listed in
                                <code class="varname">RequiresOverridable=</code>
                                which cannot be fulfilled or fail to
                                start are ignored if the startup was
                                explicitly requested by the user. If
                                the start-up was pulled in indirectly
                                by some dependency or automatic
                                start-up of units that is not
                                requested by the user this dependency
                                must be fulfilled and otherwise the
                                transaction fails. Hence, this option
                                may be used to configure dependencies
                                that are normally honored unless the
                                user explicitly starts up the unit, in
                                which case whether they failed or not
                                is irrelevant.</p></dd><dt><span class="term"><code class="varname">Requisite=</code>, </span><span class="term"><code class="varname">RequisiteOverridable=</code></span></dt><dd><p>Similar to
                                <code class="varname">Requires=</code>
                                resp. <code class="varname">RequiresOverridable=</code>. However,
                                if a unit listed here is not started
                                already it will not be started and the
                                transaction fails
                                immediately.</p></dd><dt><span class="term"><code class="varname">Wants=</code></span></dt><dd><p>A weaker version of
                                <code class="varname">Requires=</code>. A unit
                                listed in this option will be started
                                if the configuring unit is. However,
                                if the listed unit fails to start up
                                or cannot be added to the transaction
                                this has no impact on the validity of
                                the transaction as a whole. This is
                                the recommended way to hook start-up
                                of one unit to the start-up of another
                                unit. Note that dependencies of this
                                type may also be configured outside of
                                the unit configuration file by
                                adding a symlink to a
                                <code class="filename">.wants/</code> directory
                                accompanying the unit file. For
                                details see above.</p></dd><dt><span class="term"><code class="varname">BindTo=</code></span></dt><dd><p>Configures requirement
                                dependencies, very similar in style to
                                <code class="varname">Requires=</code>, however
                                in addition to this behaviour it also
                                declares that this unit is stopped
                                when any of the units listed suddenly
                                disappears. Units can suddenly,
                                unexpectedly disappear if a service
                                terminates on its own choice, a device
                                is unplugged or a mount point
                                unmounted without involvement of
                                systemd.</p></dd><dt><span class="term"><code class="varname">Conflicts=</code></span></dt><dd><p>Configures negative
                                requirement dependencies. If a unit
                                has a
                                <code class="varname">Conflicts=</code> setting
                                on another unit, starting the former
                                will stop the latter and vice
                                versa. Note that this setting is
                                independent of and orthogonal to the
                                <code class="varname">After=</code> and
                                <code class="varname">Before=</code> ordering
                                dependencies.</p><p>If a unit A that conflicts with
                                a unit B is scheduled to be started at
                                the same time as B, the transaction
                                will either fail (in case both are
                                required part of the transaction) or
                                be modified to be fixed (in case one
                                or both jobs are not a required part
                                of the transaction). In the latter
                                case the job that is not the required
                                will be removed, or in case both are
                                not required the unit that conflicts
                                will be started and the unit that is
                                conflicted is
                                stopped.</p></dd><dt><span class="term"><code class="varname">Before=</code>, </span><span class="term"><code class="varname">After=</code></span></dt><dd><p>Configures ordering
                                dependencies between units. If a unit
                                <code class="filename">foo.service</code>
                                contains a setting
                                <code class="option">Before=bar.service</code>
                                and both units are being started,
                                <code class="filename">bar.service</code>'s
                                start-up is delayed until
                                <code class="filename">foo.service</code> is
                                started up. Note that this setting is
                                independent of and orthogonal to the
                                requirement dependencies as configured
                                by <code class="varname">Requires=</code>. It is
                                a common pattern to include a unit
                                name in both the
                                <code class="varname">After=</code> and
                                <code class="varname">Requires=</code> option in
                                which case the unit listed will be
                                started before the unit that is
                                configured with these options. This
                                option may be specified more than
                                once, in which case ordering
                                dependencies for all listed names are
                                created. <code class="varname">After=</code> is
                                the inverse of
                                <code class="varname">Before=</code>, i.e. while
                                <code class="varname">After=</code> ensures that
                                the configured unit is started after
                                the listed unit finished starting up,
                                <code class="varname">Before=</code> ensures the
                                opposite, i.e.  that the configured
                                unit is fully started up before the
                                listed unit is started. Note that when
                                two units with an ordering dependency
                                between them are shut down, the
                                inverse of the start-up order is
                                applied. i.e. if a unit is configured
                                with <code class="varname">After=</code> on
                                another unit, the former is stopped
                                before the latter if both are shut
                                down. If one unit with an ordering
                                dependency on another unit is shut
                                down while the latter is started up,
                                the shut down is ordered before the
                                start-up regardless whether the
                                ordering dependency is actually of
                                type <code class="varname">After=</code> or
                                <code class="varname">Before=</code>. If two
                                units have no ordering dependencies
                                between them they are shut down
                                resp. started up simultaneously, and
                                no ordering takes
                                place. </p></dd><dt><span class="term"><code class="varname">OnFailure=</code></span></dt><dd><p>Lists one or more
                                units that are activated when this
                                unit enters the
                                '<code class="literal">failed</code>'
                                state.</p></dd><dt><span class="term"><code class="varname">OnFailureIsolate=</code></span></dt><dd><p>Takes a boolean
                                argument. If <code class="option">true</code> the
                                unit listed in
                                <code class="varname">OnFailure=</code> will be
                                enqueued in isolation mode, i.e. all
                                units that are not its dependency will
                                be stopped. If this is set only a
                                single unit may be listed in
                                <code class="varname">OnFailure=</code>. Defaults
                                to
                                <code class="option">false</code>.</p></dd><dt><span class="term"><code class="varname">IgnoreOnIsolate=</code></span></dt><dd><p>Takes a boolean
                                argument. If <code class="option">true</code>
                                this unit will not be stopped when
                                isolating another unit. Defaults to
                                <code class="option">false</code>.</p></dd><dt><span class="term"><code class="varname">IgnoreOnSnapshot=</code></span></dt><dd><p>Takes a boolean
                                argument. If <code class="option">true</code>
                                this unit will not be included in
                                snapshots. Defaults to
                                <code class="option">false</code> for device and
                                snapshot units, <code class="option">true</code>
                                for the others.</p></dd><dt><span class="term"><code class="varname">StopWhenUnneeded=</code></span></dt><dd><p>Takes a boolean
                                argument. If <code class="option">true</code>
                                this unit will be stopped when it is
                                no longer used. Note that in order to
                                minimize the work to be executed,
                                systemd will not stop units by default
                                unless they are conflicting with other
                                units, or the user explicitly
                                requested their shut down. If this
                                option is set, a unit will be
                                automatically cleaned up if no other
                                active unit requires it. Defaults to
                                <code class="option">false</code>.</p></dd><dt><span class="term"><code class="varname">RefuseManualStart=</code>, </span><span class="term"><code class="varname">RefuseManualStop=</code></span></dt><dd><p>Takes a boolean
                                argument. If <code class="option">true</code>
                                this unit can only be activated
                                (resp. deactivated) indirectly. In
                                this case explicit start-up
                                (resp. termination) requested by the
                                user is denied, however if it is
                                started (resp. stopped) as a
                                dependency of another unit, start-up
                                (resp. termination) will succeed. This
                                is mostly a safety feature to ensure
                                that the user does not accidentally
                                activate units that are not intended
                                to be activated explicitly, and not
                                accidentally deactivate units that are
                                not intended to be deactivated.
                                These options default to
                                <code class="option">false</code>.</p></dd><dt><span class="term"><code class="varname">AllowIsolate=</code></span></dt><dd><p>Takes a boolean
                                argument. If <code class="option">true</code>
                                this unit may be used with the
                                <span class="command"><strong>systemctl isolate</strong></span>
                                command. Otherwise this will be
                                refused. It probably is a good idea to
                                leave this disabled except for target
                                units that shall be used similar to
                                runlevels in SysV init systems, just
                                as a precaution to avoid unusable
                                system states. This option defaults to
                                <code class="option">false</code>.</p></dd><dt><span class="term"><code class="varname">DefaultDependencies=</code></span></dt><dd><p>Takes a boolean
                                argument. If <code class="option">true</code>
                                (the default), a few default
                                dependencies will implicitly be
                                created for the unit. The actual
                                dependencies created depend on the
                                unit type. For example, for service
                                units, these dependencies ensure that
                                the service is started only after
                                basic system initialization is
                                completed and is properly terminated on
                                system shutdown. See the respective
                                man pages for details. Generally, only
                                services involved with early boot or
                                late shutdown should set this option
                                to <code class="option">false</code>. It is
                                highly recommended to leave this
                                option enabled for the majority of
                                common units. If set to
                                <code class="option">false</code> this option
                                does not disable all implicit
                                dependencies, just non-essential
                                ones.</p></dd><dt><span class="term"><code class="varname">JobTimeoutSec=</code></span></dt><dd><p>When clients are
                                waiting for a job of this unit to
                                complete, time out after the specified
                                time. If this time limit is reached
                                the job will be cancelled, the unit
                                however will not change state or even
                                enter the '<code class="literal">failed</code>'
                                mode. This value defaults to 0 (job
                                timeouts disabled), except for device
                                units. NB: this timeout is independent
                                from any unit-specific timeout (for
                                example, the timeout set with
                                <code class="varname">Timeout=</code> in service
                                units) as the job timeout has no
                                effect on the unit itself, only on the
                                job that might be pending for it. Or
                                in other words: unit-specific timeouts
                                are useful to abort unit state
                                changes, and revert them. The job
                                timeout set with this option however
                                is useful to abort only the job
                                waiting for the unit state to
                                change.</p></dd><dt><span class="term"><code class="varname">ConditionPathExists=</code>, </span><span class="term"><code class="varname">ConditionPathIsDirectory=</code>, </span><span class="term"><code class="varname">ConditionDirectoryNotEmpty=</code>, </span><span class="term"><code class="varname">ConditionKernelCommandLine=</code>, </span><span class="term"><code class="varname">ConditionVirtualization=</code>, </span><span class="term"><code class="varname">ConditionSecurity=</code>, </span><span class="term"><code class="varname">ConditionNull=</code></span></dt><dd><p>Before starting a unit
                                verify that the specified condition is
                                true. With
                                <code class="varname">ConditionPathExists=</code>
                                a file existance condition can be
                                checked before a unit is started. If
                                the specified absolute path name does
                                not exist startup of a unit will not
                                actually happen, however the unit is
                                still useful for ordering purposes in
                                this case. The condition is checked at
                                the time the queued start job is to be
                                executed. If the absolute path name
                                passed to
                                <code class="varname">ConditionPathExists=</code>
                                is prefixed with an exclamation mark
                                (!), the test is negated, and the unit
                                only started if the path does not
                                exist. <code class="varname">ConditionPathIsDirectory=</code>
                                is similar to
                                <code class="varname">ConditionPathExists=</code>
                                but verifies whether a certain path
                                exists and is a directory.
                                <code class="varname">ConditionDirectoryNotEmpty=</code>
                                is similar to
                                <code class="varname">ConditionPathExists=</code>
                                but verifies whether a certain path
                                exists and is a non-empty
                                directory. Similarly
                                <code class="varname">ConditionKernelCommandLine=</code>
                                may be used to check whether a
                                specific kernel command line option is
                                set (or if prefixed with the
                                exclamation mark unset). The argument
                                must either be a single word, or an
                                assignment (i.e. two words, separated
                                by the equality sign). In the former
                                case the kernel command line is
                                searched for the word appearing as is,
                                or as left hand side of an
                                assignment. In the latter case the
                                exact assignment is looked for with
                                right and left hand side
                                matching. <code class="varname">ConditionVirtualization=</code>
                                may be used to check whether the
                                system is executed in a virtualized
                                environment and optionally test
                                whether it is a specific
                                implementation. Takes either boolean
                                value to check if being executed in
                                any virtual environment or one of the
                                <code class="varname">qemu</code>,
                                <code class="varname">kvm</code>,
                                <code class="varname">vmware</code>,
                                <code class="varname">microsoft</code>,
                                <code class="varname">oracle</code>,
                                <code class="varname">xen</code>,
                                <code class="varname">pidns</code>,
                                <code class="varname">openvz</code> to test
                                against a specific implementation. The
                                test may be negated by prepending an
                                exclamation mark.
                                <code class="varname">ConditionSecurity=</code>
                                may be used to check whether the given security
                                module is enabled on the system.
                                Currently the only recognized value is
                                <code class="varname">selinux</code>.
                                The test may be negated by prepending an
                                exclamation mark. Finally,
                                <code class="varname">ConditionNull=</code> may
                                be used to add a constant condition
                                check value to the unit. It takes a
                                boolean argument. If set to
                                <code class="varname">false</code> the condition
                                will always fail, otherwise
                                succeed. If multiple conditions are
                                specified the unit will be executed if
                                all of them apply (i.e. a logical AND
                                is applied). Condition checks can be
                                prefixed with a pipe symbol (|) in
                                which case a condition becomes a
                                triggering condition. If at least one
                                triggering condition is defined for a
                                unit then the unit will be executed if
                                at least one of the triggering
                                conditions apply and all of the
                                non-triggering conditions. If you
                                prefix an argument with the pipe
                                symbol and an exclamation mark the
                                pipe symbol must be passed first, the
                                exclamation second.</p></dd><dt><span class="term"><code class="varname">Names=</code></span></dt><dd><p>Additional names for
                                this unit. The names listed here must
                                have the same suffix (i.e. type) as
                                the unit file name. This option may be
                                specified more than once, in which
                                case all listed names are used. Note
                                that this option is different from the
                                <code class="varname">Alias=</code> option from
                                the [Install] section mentioned
                                below. See below for details. Note
                                that in almost all cases this option
                                is not what you want. A symlink alias
                                in the file system is generally
                                preferable since it can be used as
                                lookup key. If a unit with a symlinked
                                alias name is not loaded and needs to
                                be it is easily found via the
                                symlink. However, if a unit with an
                                alias name configured with this
                                setting is not loaded it will not be
                                discovered. This settings' only use is
                                in conjunction with service
                                instances.</p></dd></dl></div><p>Unit file may include a [Install] section, which
                carries installation information for the unit. This
                section is not interpreted by
                <span class="citerefentry"><span class="refentrytitle">systemd</span>(1)</span>
                during runtime. It is used exclusively by the
                <span class="command"><strong>enable</strong></span> and
                <span class="command"><strong>disable</strong></span> commands of the
                <span class="citerefentry"><span class="refentrytitle">systemctl</span>(1)</span>
                tool during installation of a unit:</p><div class="variablelist"><dl><dt><span class="term"><code class="varname">Alias=</code></span></dt><dd><p>Additional names this
                                unit shall be installed under. The
                                names listed here must have the same
                                suffix (i.e. type) as the unit file
                                name. This option may be specified
                                more than once, in which case all
                                listed names are used. At installation
                                time,
                                <span class="command"><strong>systemctl enable</strong></span>
                                will create symlinks from these names
                                to the unit file name. Note that this
                                is different from the
                                <code class="varname">Names=</code> option from
                                the [Unit] section mentioned above:
                                The names from
                                <code class="varname">Names=</code> apply
                                unconditionally if the unit is
                                loaded. The names from
                                <code class="varname">Alias=</code> apply only
                                if the unit has actually been
                                installed with the
                                <span class="command"><strong>systemctl enable</strong></span>
                                command.  Also, if systemd searches for a
                                unit, it will discover symlinked alias
                                names as configured with
                                <code class="varname">Alias=</code>, but not
                                names configured with
                                <code class="varname">Names=</code> only. It is
                                a common pattern to list a name in
                                both options. In this case, a unit
                                will be active under all names if
                                installed, but also if not installed
                                but requested explicitly under its
                                main name.</p></dd><dt><span class="term"><code class="varname">WantedBy=</code></span></dt><dd><p>Installs a symlink in
                                the <code class="filename">.wants/</code>
                                subdirectory for a unit. This has the
                                effect that when the listed unit name
                                is activated the unit listing it is
                                activated
                                too. <span class="command"><strong>WantedBy=foo.service</strong></span>
                                in a service
                                <code class="filename">bar.service</code> is
                                mostly equivalent to
                                <span class="command"><strong>Alias=foo.service.wants/bar.service</strong></span>
                                in the same file.</p></dd><dt><span class="term"><code class="varname">Also=</code></span></dt><dd><p>Additional units to
                                install when this unit is
                                installed. If the user requests
                                installation of a unit with this
                                option configured,
                                <span class="command"><strong>systemctl enable</strong></span>
                                will automatically install units
                                listed in this option as
                                well.</p></dd></dl></div></div><div class="refsect1" title="See Also"><a id="id388756"/><h2>See Also</h2><p>
                        <span class="citerefentry"><span class="refentrytitle">systemd</span>(1)</span>,
                        <span class="citerefentry"><span class="refentrytitle">systemctl</span>(8)</span>,
                        <span class="citerefentry"><span class="refentrytitle">systemd.special</span>(7)</span>,
                        <span class="citerefentry"><span class="refentrytitle">systemd.service</span>(5)</span>,
                        <span class="citerefentry"><span class="refentrytitle">systemd.socket</span>(5)</span>,
                        <span class="citerefentry"><span class="refentrytitle">systemd.device</span>(5)</span>,
                        <span class="citerefentry"><span class="refentrytitle">systemd.mount</span>(5)</span>,
                        <span class="citerefentry"><span class="refentrytitle">systemd.automount</span>(5)</span>,
                        <span class="citerefentry"><span class="refentrytitle">systemd.swap</span>(5)</span>,
                        <span class="citerefentry"><span class="refentrytitle">systemd.target</span>(5)</span>,
                        <span class="citerefentry"><span class="refentrytitle">systemd.path</span>(5)</span>,
                        <span class="citerefentry"><span class="refentrytitle">systemd.timer</span>(5)</span>,
                        <span class="citerefentry"><span class="refentrytitle">systemd.snapshot</span>(5)</span>
                </p></div></div></body></html>
