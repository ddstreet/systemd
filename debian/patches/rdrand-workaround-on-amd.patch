From: Jeremy Soller <jeremy@system76.com>
Date: Tue, 9 Jul 2019 11:31:46 +0200
Subject: random-util: eat up bad RDRAND values seen on AMD CPUs

This fixes AMD Ryzen 3000 series failing to boot
From https://github.com/systemd/systemd/pull/12536

LP: #1835809
===================================================================
---
 src/basic/random-util.c | 16 +++++++++++++++-
 1 file changed, 15 insertions(+), 1 deletion(-)

diff --git a/src/basic/random-util.c b/src/basic/random-util.c
index f7decf6..857027f 100644
--- a/src/basic/random-util.c
+++ b/src/basic/random-util.c
@@ -37,6 +37,7 @@ int rdrand(unsigned long *ret) {
 
 #if defined(__i386__) || defined(__x86_64__)
         static int have_rdrand = -1;
+        unsigned long v;
         unsigned char err;
 
         if (have_rdrand < 0) {
@@ -56,9 +57,22 @@ int rdrand(unsigned long *ret) {
 
         asm volatile("rdrand %0;"
                      "setc %1"
-                     : "=r" (*ret),
+                     : "=r" (v),
                        "=qm" (err));
 
+       /* Apparently on some AMD CPUs RDRAND will sometimes (after a suspend/resume cycle?) report success
+        * via the carry flag but nonetheless return the same fixed value -1 in all cases. This appears to be
+        * a bad bug in the CPU or firmware. Let's deal with that and work-around this by explicitly checking
+        * for this special value (and also 0, just to be sure) and filtering it out. This is a work-around
+        * only however and something AMD really should fix properly. The Linux kernel should probably work
+        * around this issue by turning off RDRAND altogether on those CPUs. See:
+        * https://github.com/systemd/systemd/issues/11810 */
+       if (v == 0 || v == ULONG_MAX)
+               return log_debug_errno(SYNTHETIC_ERRNO(EUCLEAN),
+                                      "RDRAND returned suspicious value %lx, assuming bad hardware RNG, not using value.", v);
+
+       *ret = v;
+
 #if HAS_FEATURE_MEMORY_SANITIZER
         __msan_unpoison(&err, sizeof(err));
 #endif
