From 57ad76074670d4859e808a6aabd69fd6e58514c5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Zbigniew=20J=C4=99drzejewski-Szmek?= <zbyszek@in.waw.pl>
Date: Thu, 22 Aug 2019 13:26:54 +0200
Subject: [PATCH] network: drop all checks of ipv6_disabled sysctl
Bug-Ubuntu: https://bugs.launchpad.net/ubuntu/eoan/+source/systemd/+bug/1877271
Origin: upstream, https://github.com/systemd/systemd/commit/57ad76074670d4859e808a6aabd69fd6e58514c5

*We* control the sysctl setting. If the user configured IPv6, then we apply the
settings, and just make sure that at some point during the configuration the
sysctl is disabled (i.e. ipv6 enabled) if we have IPv6 configured.

Replaces #13283.
---
 src/network/networkd-address.c              |  5 ---
 src/network/networkd-fdb.c                  |  5 ---
 src/network/networkd-link.c                 | 44 +++------------------
 src/network/networkd-link.h                 |  3 --
 src/network/networkd-route.c                |  5 ---
 src/network/networkd-routing-policy-rule.c  |  5 ---
 test/test-network/systemd-networkd-tests.py |  5 ++-
 7 files changed, 8 insertions(+), 64 deletions(-)

--- a/src/network/networkd-address.c
+++ b/src/network/networkd-address.c
@@ -566,11 +566,6 @@ int address_configure(
         assert(link->manager->rtnl);
         assert(callback);
 
-        if (address->family == AF_INET6 && link_sysctl_ipv6_enabled(link) == 0) {
-                log_link_warning(link, "An IPv6 address is requested, but IPv6 is disabled by sysctl, ignoring.");
-                return 0;
-        }
-
         /* If this is a new address, then refuse adding more than the limit */
         if (address_get(link, address->family, &address->in_addr, address->prefixlen, NULL) <= 0 &&
             set_size(link->addresses) >= ADDRESSES_PER_LINK_MAX)
--- a/src/network/networkd-link.c
+++ b/src/network/networkd-link.c
@@ -60,20 +60,6 @@ DUID* link_get_duid(Link *link) {
                 return &link->manager->duid;
 }
 
-int link_sysctl_ipv6_enabled(Link *link) {
-        _cleanup_free_ char *value = NULL;
-        int r;
-
-        r = sysctl_read_ip_property(AF_INET6, link->ifname, "disable_ipv6", &value);
-        if (r < 0)
-                return log_link_warning_errno(link, r,
-                                              "Failed to read net.ipv6.conf.%s.disable_ipv6 sysctl property: %m",
-                                              link->ifname);
-
-        link->sysctl_ipv6_enabled = value[0] == '0';
-        return link->sysctl_ipv6_enabled;
-}
-
 static bool link_dhcp6_enabled(Link *link) {
         assert(link);
 
@@ -89,9 +75,6 @@ static bool link_dhcp6_enabled(Link *lin
         if (link->network->bond)
                 return false;
 
-        if (link_sysctl_ipv6_enabled(link) == 0)
-                return false;
-
         return link->network->dhcp & ADDRESS_FAMILY_IPV6;
 }
 
@@ -161,9 +144,6 @@ static bool link_ipv6ll_enabled(Link *li
         if (link->network->bond)
                 return false;
 
-        if (link_sysctl_ipv6_enabled(link) == 0)
-                return false;
-
         return link->network->link_local & ADDRESS_FAMILY_IPV6;
 }
 
@@ -176,9 +156,6 @@ static bool link_ipv6_enabled(Link *link
         if (link->network->bond)
                 return false;
 
-        if (link_sysctl_ipv6_enabled(link) == 0)
-                return false;
-
         /* DHCPv6 client will not be started if no IPv6 link-local address is configured. */
         return link_ipv6ll_enabled(link) || network_has_static_ipv6_addresses(link->network);
 }
@@ -258,9 +235,6 @@ static bool link_ipv6_forward_enabled(Li
         if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                 return false;
 
-        if (link_sysctl_ipv6_enabled(link) == 0)
-                return false;
-
         return link->network->ip_forward & ADDRESS_FAMILY_IPV6;
 }
 
@@ -331,7 +305,7 @@ static IPv6PrivacyExtensions link_ipv6_p
         return link->network->ipv6_privacy_extensions;
 }
 
-static int link_enable_ipv6(Link *link) {
+static int link_update_ipv6_sysctl(Link *link) {
         bool enabled;
         int r;
 
@@ -342,9 +316,9 @@ static int link_enable_ipv6(Link *link)
         if (enabled) {
                 r = sysctl_write_ip_property_boolean(AF_INET6, link->ifname, "disable_ipv6", false);
                 if (r < 0)
-                        log_link_warning_errno(link, r, "Cannot enable IPv6: %m");
-                else
-                        log_link_info(link, "IPv6 successfully enabled");
+                        return log_link_warning_errno(link, r, "Cannot enable IPv6: %m");
+
+                log_link_info(link, "IPv6 successfully enabled");
         }
 
         return 0;
@@ -581,7 +555,6 @@ static int link_new(Manager *manager, sd
                 .rtnl_extended_attrs = true,
                 .ifindex = ifindex,
                 .iftype = iftype,
-                .sysctl_ipv6_enabled = -1,
         };
 
         link->ifname = strdup(ifname);
@@ -3218,7 +3191,7 @@ static int link_configure(Link *link) {
 
         /* If IPv6 configured that is static IPv6 address and IPv6LL autoconfiguration is enabled
          * for this interface, then enable IPv6 */
-        (void) link_enable_ipv6(link);
+        (void) link_update_ipv6_sysctl(link);
 
         r = link_set_proxy_arp(link);
         if (r < 0)
--- a/src/network/networkd-link.h
+++ b/src/network/networkd-link.h
@@ -124,8 +124,6 @@ typedef struct Link {
         Hashmap *bound_by_links;
         Hashmap *bound_to_links;
         Hashmap *slaves;
-
-        int sysctl_ipv6_enabled;
 } Link;
 
 typedef int (*link_netlink_message_handler_t)(sd_netlink*, sd_netlink_message*, Link*);
@@ -187,8 +185,6 @@ uint32_t link_get_dhcp_route_table(Link
 uint32_t link_get_ipv6_accept_ra_route_table(Link *link);
 int link_request_set_routes(Link *link);
 
-int link_sysctl_ipv6_enabled(Link *link);
-
 #define ADDRESS_FMT_VAL(address)                   \
         be32toh((address).s_addr) >> 24,           \
         (be32toh((address).s_addr) >> 16) & 0xFFu, \
--- a/src/network/networkd-route.c
+++ b/src/network/networkd-route.c
@@ -498,11 +498,6 @@ int route_configure(
         assert(IN_SET(route->family, AF_INET, AF_INET6));
         assert(callback);
 
-        if (route->family == AF_INET6 && link_sysctl_ipv6_enabled(link) == 0) {
-                log_link_warning(link, "An IPv6 route is requested, but IPv6 is disabled by sysctl, ignoring.");
-                return 0;
-        }
-
         if (route_get(link, route->family, &route->dst, route->dst_prefixlen, route->tos, route->priority, route->table, NULL) <= 0 &&
             set_size(link->routes) >= routes_max())
                 return log_link_error_errno(link, SYNTHETIC_ERRNO(E2BIG),
--- a/src/network/networkd-routing-policy-rule.c
+++ b/src/network/networkd-routing-policy-rule.c
@@ -484,11 +484,6 @@ int routing_policy_rule_configure(Routin
         assert(link->manager);
         assert(link->manager->rtnl);
 
-        if (rule->family == AF_INET6 && link_sysctl_ipv6_enabled(link) == 0) {
-                log_link_warning(link, "An IPv6 routing policy rule is requested, but IPv6 is disabled by sysctl, ignoring.");
-                return 0;
-        }
-
         r = sd_rtnl_message_new_routing_policy_rule(link->manager->rtnl, &m, RTM_NEWRULE, rule->family);
         if (r < 0)
                 return log_error_errno(r, "Could not allocate RTM_NEWRULE message: %m");
