Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 systemd (44-10ubuntu1) raring; urgency=low
 .
   * Split logind into its own binary package, for use on non-systemd systems.
   * Drop the systemd binary package from the build.
   * Drop the systemd-gui package, not usable without systemd.
   * Have logind declare a Replaces: on systemd for the moved files, even
     though we're not shipping the systemd binary package in Ubuntu.
   * libpam-systemd should depend on logind, not on systemd.
   * Enable pam_systemd use on non-systemd systems.
   * cherry-pick from upstream to fix build with eglibc 2.17.
   * export V=1 so we get meaningful build logs.
   * Don't build systemd-sysv package on Ubuntu.
   * Split hostname, locale, and timedate services into a new binary package,
     systemd-services.
   * Fix up dbus service definitions to work when not started by systemd.
   * Adjust localed to use the Debian locations of /etc/default/locale and
     /etc/default/keyboard for locale data, not /etc/locale.conf and
     /etc/X11/xorg.conf.d/00-keyboard.conf.
   * Ditch the use of faketime; it's in universe, and all it does in Ubuntu
     is segfault.  This may reduce the multiarch-friendliness of the library
     packages, but that's not actually needed here since nothing except logind
     is using those libraries anyway.
   * Move dbus services from /lib/systemd to /usr/lib/systemd.
Author: Steve Langasek <steve.langasek@ubuntu.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- systemd-44.orig/TODO
+++ systemd-44/TODO
@@ -18,6 +18,8 @@ Bugfixes:
 
 Features:
 
+* dbus upstream still refers to dbus.target and shouldn't
+
 * journald: make configurable "store-on-var", "store-on-run", "dont-store", "auto"
   (store-persistent, store-volatile?)
 
--- systemd-44.orig/configure.ac
+++ systemd-44/configure.ac
@@ -109,7 +109,7 @@ CC_CHECK_CFLAGS_APPEND([ \
 LT_PREREQ(2.2)
 LT_INIT
 
-AC_SEARCH_LIBS([clock_gettime], [rt], [], [AC_MSG_ERROR([*** POSIX RT library not found])])
+AC_SEARCH_LIBS([mq_open], [rt], [], [AC_MSG_ERROR([*** POSIX RT library not found])])
 AC_SEARCH_LIBS([dlsym], [dl], [], [AC_MSG_ERROR([*** Dynamic linking loader library not found])])
 
 save_LIBS="$LIBS"
--- systemd-44.orig/Makefile.am
+++ systemd-44/Makefile.am
@@ -294,7 +294,6 @@ dist_systemunit_DATA = \
 	units/sys-kernel-security.mount \
 	units/sys-fs-fuse-connections.mount \
 	units/var-run.mount \
-	units/media.mount \
 	units/remount-rootfs.service \
 	units/printer.target \
 	units/sound.target \
@@ -2202,6 +2201,8 @@ XSLTPROC_FLAGS = \
 	--nonet \
 	--stringparam funcsynopsis.style ansi
 
+T=$(shell dpkg-parsechangelog | awk -F": " '$$1 == "Date" { print $$2 }')
+
 XSLTPROC_PROCESS_MAN = \
 	$(AM_V_GEN)$(MKDIR_P) $(dir $@) && \
 	$(XSLTPROC) -o $@ $(XSLTPROC_FLAGS) http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl $<
@@ -2306,13 +2307,11 @@ systemd-install-data-hook:
 		rm -f systemd-remount-api-vfs.service \
 			fsck-root.service \
 			remount-rootfs.service \
-			var-run.mount \
-			media.mount && \
+			var-run.mount && \
 		$(LN_S) ../systemd-remount-api-vfs.service systemd-remount-api-vfs.service && \
 		$(LN_S) ../fsck-root.service fsck-root.service && \
 		$(LN_S) ../remount-rootfs.service remount-rootfs.service && \
-		$(LN_S) ../var-run.mount var-run.mount && \
-		$(LN_S) ../media.mount media.mount )
+		$(LN_S) ../var-run.mount var-run.mount )
 	( cd $(DESTDIR)$(userunitdir) && \
 		rm -f shutdown.target sockets.target bluetooth.target printer.target sound.target && \
 		$(LN_S) $(systemunitdir)/shutdown.target shutdown.target && \
--- systemd-44.orig/man/systemd.socket.xml
+++ systemd-44/man/systemd.socket.xml
@@ -75,7 +75,7 @@
                 <option>ExecStartPre=</option>,
                 <option>ExecStartPost=</option>,
                 <option>ExecStopPre=</option> and
-                <option>ExecStoptPost=</option> commands are executed
+                <option>ExecStopPost=</option> commands are executed
                 in.</para>
 
                 <para>For each socket file a matching service file
--- systemd-44.orig/man/systemd.path.xml
+++ systemd-44/man/systemd.path.xml
@@ -125,7 +125,7 @@
                                 is
                                 activated. <varname>PathExistsGlob=</varname>
                                 works similar, but checks for the
-                                existance of at least one file
+                                existence of at least one file
                                 matching the globbing pattern
                                 specified. <varname>PathChanged=</varname>
                                 may be used to watch a file or
--- systemd-44.orig/man/systemd.mount.xml
+++ systemd-44/man/systemd.mount.xml
@@ -112,13 +112,13 @@
                 points from <filename>/etc/fstab</filename>. If
                 <option>MountAuto=yes</option> is set in
                 <filename>system.conf</filename> (which is the
-                default), or if <option>x-systemd.mount</option> is
+                default), or if <option>comment=systemd.mount</option> is
                 specified as mount option, then systemd will create a
                 dependency of type <option>Wants</option> from either
                 <filename>local-fs.target</filename> or
                 <filename>remote-fs.target</filename>, depending
                 whether the file system is local or remote. If
-                <option>x-systemd.automount</option> is set, an
+                <option>comment=systemd.automount</option> is set, an
                 automount unit will be created for the file
                 system. See
                 <citerefentry><refentrytitle>systemd.automount</refentrytitle><manvolnum>5</manvolnum></citerefentry>
--- systemd-44.orig/man/systemd.unit.xml
+++ systemd-44/man/systemd.unit.xml
@@ -122,7 +122,7 @@
                 <para>If a line starts with <option>.include</option>
                 followed by a file name, the specified file will be
                 parsed at this point. Make sure that the file that is
-                included has the appropiate section headers before
+                included has the appropriate section headers before
                 any directives.</para>
 
                 <para>Along with a unit file
--- systemd-44.orig/src/99-systemd.rules.in
+++ systemd-44/src/99-systemd.rules.in
@@ -6,6 +6,7 @@
 #  (at your option) any later version.
 
 ACTION=="remove", GOTO="systemd_end"
+TEST!="/sys/fs/cgroup/systemd", GOTO="systemd_end"
 
 SUBSYSTEM=="tty", KERNEL=="tty[0-9]|tty1[0-2]", TAG+="systemd"
 SUBSYSTEM=="tty", KERNEL=="tty[a-zA-Z]*|hvc*|xvc*|hvsi*", TAG+="systemd"
--- systemd-44.orig/src/systemctl.c
+++ systemd-44/src/systemctl.c
@@ -761,7 +761,7 @@ static int dot_one_property(const char *
                 "RequiresOverridable",   "[color=\"black\"]",
                 "Requisite",             "[color=\"darkblue\"]",
                 "RequisiteOverridable",  "[color=\"darkblue\"]",
-                "Wants",                 "[color=\"darkgrey\"]",
+                "Wants",                 "[color=\"grey66\"]",
                 "Conflicts",             "[color=\"red\"]",
                 "ConflictedBy",          "[color=\"red\"]",
                 "After",                 "[color=\"green\"]"
--- systemd-44.orig/src/cgtop.c
+++ systemd-44/src/cgtop.c
@@ -340,17 +340,22 @@ static int refresh(Hashmap *a, Hashmap *
 
         r = refresh_one("name=systemd", "/", a, b, iteration, 0);
         if (r < 0)
-                return r;
-
+                if (r != -ENOENT)
+                    return r;
         r = refresh_one("cpuacct", "/", a, b, iteration, 0);
         if (r < 0)
-                return r;
-
+                if (r != -ENOENT)
+                    return r;
         r = refresh_one("memory", "/", a, b, iteration, 0);
         if (r < 0)
-                return r;
+                if (r != -ENOENT)
+                    return r;
 
-        return refresh_one("blkio", "/", a, b, iteration, 0);
+        r = refresh_one("blkio", "/", a, b, iteration, 0);
+        if (r < 0)
+                if (r != -ENOENT)
+                    return r;
+        return 0;
 }
 
 static int group_compare(const void*a, const void *b) {
--- systemd-44.orig/src/service.c
+++ systemd-44/src/service.c
@@ -344,7 +344,7 @@ static int sysv_translate_facility(const
                 "network",              SPECIAL_NETWORK_TARGET,
 #endif
                 "named",                SPECIAL_NSS_LOOKUP_TARGET,
-                "portmap",              SPECIAL_RPCBIND_TARGET,
+                "portmap",              SPECIAL_RPCBIND_SERVICE,
                 "remote_fs",            SPECIAL_REMOTE_FS_TARGET,
                 "syslog",               SPECIAL_SYSLOG_TARGET,
                 "time",                 SPECIAL_TIME_SYNC_TARGET,
@@ -494,7 +494,7 @@ static ExecCommand *exec_command_new(con
         return c;
 }
 
-static int sysv_exec_commands(Service *s) {
+static int sysv_exec_commands(Service *s, const bool supports_reload) {
         ExecCommand *c;
 
         assert(s);
@@ -508,13 +508,24 @@ static int sysv_exec_commands(Service *s
                 return -ENOMEM;
         exec_command_append_list(s->exec_command+SERVICE_EXEC_STOP, c);
 
-        if (!(c = exec_command_new(s->sysv_path, "reload")))
-                return -ENOMEM;
-        exec_command_append_list(s->exec_command+SERVICE_EXEC_RELOAD, c);
+        if (supports_reload) {
+                if (!(c = exec_command_new(s->sysv_path, "reload")))
+                        return -ENOMEM;
+                exec_command_append_list(s->exec_command+SERVICE_EXEC_RELOAD, c);
+        }
 
         return 0;
 }
 
+static bool usage_contains_reload(const char *line) {
+        return (strcasestr(line, "{reload|") ||
+                strcasestr(line, "{reload}") ||
+                strcasestr(line, "{reload\"") ||
+                strcasestr(line, "|reload|") ||
+                strcasestr(line, "|reload}") ||
+                strcasestr(line, "|reload\""));
+}
+
 static int service_load_sysv_path(Service *s, const char *path) {
         FILE *f;
         Unit *u;
@@ -524,10 +535,12 @@ static int service_load_sysv_path(Servic
                 NORMAL,
                 DESCRIPTION,
                 LSB,
-                LSB_DESCRIPTION
+                LSB_DESCRIPTION,
+                USAGE_CONTINUATION
         } state = NORMAL;
         char *short_description = NULL, *long_description = NULL, *chkconfig_description = NULL, *description;
         struct stat st;
+        bool supports_reload = false;
 
         assert(s);
         assert(path);
@@ -574,8 +587,23 @@ static int service_load_sysv_path(Servic
                 line++;
 
                 t = strstrip(l);
-                if (*t != '#')
+                if (*t != '#') {
+                        /* Try to figure out whether this init script supports
+                         * the reload operation. This heuristic looks for
+                         * "Usage" lines which include the reload option. */
+                        if ( state == USAGE_CONTINUATION ||
+                            (state == NORMAL && strcasestr(t, "usage"))) {
+                                if (usage_contains_reload(t)) {
+                                        supports_reload = true;
+                                        state = NORMAL;
+                                } else if (t[strlen(t)-1] == '\\')
+                                        state = USAGE_CONTINUATION;
+                                else
+                                        state = NORMAL;
+                        }
+
                         continue;
+                }
 
                 if (state == NORMAL && streq(t, "### BEGIN INIT INFO")) {
                         state = LSB;
@@ -868,7 +896,7 @@ static int service_load_sysv_path(Servic
                 }
         }
 
-        if ((r = sysv_exec_commands(s)) < 0)
+        if ((r = sysv_exec_commands(s, supports_reload)) < 0)
                 goto finish;
         if (s->sysv_runlevels &&
             chars_intersect(RUNLEVELS_BOOT, s->sysv_runlevels) &&
@@ -2094,7 +2122,8 @@ static void service_enter_start(Service
         /* We want to ensure that nobody leaks processes from
          * START_PRE here, so let's go on a killing spree, People
          * should not spawn long running processes from START_PRE. */
-        cgroup_bonding_kill_list(UNIT(s)->cgroup_bondings, SIGKILL, true, NULL);
+        // F17, bz816842, bz805942
+        //cgroup_bonding_kill_list(UNIT(s)->cgroup_bondings, SIGKILL, true, NULL);
 
         if (s->type == SERVICE_FORKING) {
                 s->control_command_id = SERVICE_EXEC_START;
@@ -2168,7 +2197,8 @@ static void service_enter_start_pre(Serv
 
                 /* Before we start anything, let's clear up what might
                  * be left from previous runs. */
-                cgroup_bonding_kill_list(UNIT(s)->cgroup_bondings, SIGKILL, true, NULL);
+                // F17, bz816842, bz805942
+                //cgroup_bonding_kill_list(UNIT(s)->cgroup_bondings, SIGKILL, true, NULL);
 
                 s->control_command_id = SERVICE_EXEC_START_PRE;
 
--- systemd-44.orig/src/manager.c
+++ systemd-44/src/manager.c
@@ -1700,6 +1700,8 @@ static int transaction_add_isolate_jobs(
 int manager_add_job(Manager *m, JobType type, Unit *unit, JobMode mode, bool override, DBusError *e, Job **_ret) {
         int r;
         Job *ret;
+        Job *j;
+        Iterator i;
 
         assert(m);
         assert(type < _JOB_TYPE_MAX);
@@ -1711,6 +1713,45 @@ int manager_add_job(Manager *m, JobType
                 return -EINVAL;
         }
 
+        if (type == JOB_RELOAD || type == JOB_RELOAD_OR_START || type == JOB_RESTART || type == JOB_TRY_RESTART) {
+                /* If final.target is queued (happens on poweroff, reboot and
+                 * halt), we will not accept new reload jobs. They would not be
+                 * executed ever anyways (since the shutdown comes first), but
+                 * they block the shutdown process: when systemd tries to stop
+                 * a unit such as ifup@eth0.service, that unit might invoke a
+                 * systemctl reload command, which blockingly waits (but only
+                 * gets executed after all other queued units for the shutdown
+                 * have been executed).
+                 *
+                 * See http://bugs.debian.org/624599 and
+                 *     http://bugs.debian.org/635777 */
+                HASHMAP_FOREACH(j, m->jobs, i) {
+                        assert(j->installed);
+
+                        if (strcmp(j->unit->id, "final.target") == 0) {
+                                log_debug("final.target is queued, ignoring %s request for unit %s", job_type_to_string(type), unit->id);
+                                dbus_set_error(e, BUS_ERROR_INVALID_JOB_MODE, "final.target is queued, ignoring %s request for unit %s", job_type_to_string(type), unit->id);
+                                return -EINVAL;
+                        }
+                        /* Trying to reload services from multi-user.target
+                         * during the early boot stage can lead to deadlocks.
+                         * An example is samba being reloaded by the dhcp hook
+                         * when the network is activated during rcS.
+                         * As a workaround we ignore reload or (re)start
+                         * requests while sysinit.target is queued for
+                         * services which have the DefaultDependencies option
+                         * set to yes.
+                         *
+                         * See http://bugs.debian.org/624599 */
+                        if (strcmp(j->unit->id, "sysinit.target") == 0 && unit->default_dependencies) {
+                                log_debug("sysinit.target is queued, ignoring %s request for unit %s", job_type_to_string(type), unit->id);
+                                dbus_set_error(e, BUS_ERROR_INVALID_JOB_MODE, "sysinit.target is queued, ignoring %s request for unit %s", job_type_to_string(type), unit->id);
+                                return -EINVAL;
+                        }
+                }
+        }
+
+
         if (mode == JOB_ISOLATE && !unit->allow_isolate) {
                 dbus_set_error(e, BUS_ERROR_NO_ISOLATION, "Operation refused, unit may not be isolated.");
                 return -EPERM;
--- systemd-44.orig/src/mount.c
+++ systemd-44/src/mount.c
@@ -390,7 +390,7 @@ static int mount_add_fstab_links(Mount *
                 else /* automount + nofail */
                         return unit_add_two_dependencies(tu, UNIT_AFTER, UNIT_WANTS, am, true);
 
-        } else if (handle && !noauto) {
+        } else if (handle && !noauto && !mount_is_network(p)) {
 
                 /* Automatically add mount points that aren't natively
                  * configured to local-fs.target */
--- systemd-44.orig/src/util.c
+++ systemd-44/src/util.c
@@ -3593,7 +3593,8 @@ static int rm_rf_children(int fd, bool o
                 if (is_dir) {
                         int subdir_fd;
 
-                        if ((subdir_fd = openat(fd, de->d_name, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC)) < 0) {
+                        subdir_fd = openat(fd, de->d_name, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW);
+                        if (subdir_fd < 0) {
                                 if (ret == 0 && errno != ENOENT)
                                         ret = -errno;
                                 continue;
--- systemd-44.orig/src/special.h
+++ systemd-44/src/special.h
@@ -54,7 +54,7 @@
 /* LSB compatibility */
 #define SPECIAL_NETWORK_TARGET "network.target"           /* LSB's $network */
 #define SPECIAL_NSS_LOOKUP_TARGET "nss-lookup.target"     /* LSB's $named */
-#define SPECIAL_RPCBIND_TARGET "rpcbind.target"           /* LSB's $portmap */
+#define SPECIAL_RPCBIND_SERVICE "rpcbind.service"         /* LSB's $portmap */
 #define SPECIAL_SYSLOG_TARGET "syslog.target"             /* LSB's $syslog; Should pull in syslog.socket or syslog.service */
 #define SPECIAL_TIME_SYNC_TARGET "time-sync.target"       /* LSB's $time */
 #define SPECIAL_DISPLAY_MANAGER_SERVICE "display-manager.service"       /* Debian's $x-display-manager */
--- systemd-44.orig/src/journal/journal-file.c
+++ systemd-44/src/journal/journal-file.c
@@ -67,9 +67,12 @@ void journal_file_close(JournalFile *f)
 
         assert(f);
 
-        if (f->header && f->writable)
-                f->header->state = STATE_OFFLINE;
+        if (f->header) {
+                if (f->writable)
+                        f->header->state = STATE_OFFLINE;
 
+                munmap(f->header, PAGE_ALIGN(sizeof(Header)));
+        }
 
         for (t = 0; t < _WINDOW_MAX; t++)
                 if (f->windows[t].ptr)
@@ -1887,7 +1890,10 @@ int journal_file_open_reliably(
         char *p;
 
         r = journal_file_open(fname, flags, mode, template, ret);
-        if (r != -EBADMSG)
+        if (r != -EBADMSG && /* corrupted */
+            r != -ENODATA && /* truncated */
+            r != -EHOSTDOWN && /* other machine */
+            r != -EPROTONOSUPPORT) /* incompatible feature */
                 return r;
 
         if ((flags & O_ACCMODE) == O_RDONLY)
--- systemd-44.orig/src/journal/journald.c
+++ systemd-44/src/journal/journald.c
@@ -29,7 +29,6 @@
 #include <sys/ioctl.h>
 #include <linux/sockios.h>
 #include <sys/statvfs.h>
-#include <sys/user.h>
 
 #include <systemd/sd-journal.h>
 #include <systemd/sd-login.h>
@@ -330,7 +329,10 @@ static void server_rotate(Server *s) {
         if (s->runtime_journal) {
                 r = journal_file_rotate(&s->runtime_journal);
                 if (r < 0)
-                        log_error("Failed to rotate %s: %s", s->runtime_journal->path, strerror(-r));
+                        if (s->runtime_journal)
+                                log_error("Failed to rotate %s: %s", s->runtime_journal->path, strerror(-r));
+                        else
+                                log_error("Failed to create new runtime journal: %s", strerror(-r));
                 else
                         server_fix_perms(s, s->runtime_journal, 0);
         }
@@ -338,7 +340,11 @@ static void server_rotate(Server *s) {
         if (s->system_journal) {
                 r = journal_file_rotate(&s->system_journal);
                 if (r < 0)
-                        log_error("Failed to rotate %s: %s", s->system_journal->path, strerror(-r));
+                        if (s->system_journal)
+                                log_error("Failed to rotate %s: %s", s->system_journal->path, strerror(-r));
+                        else
+                                log_error("Failed to create new system journal: %s", strerror(-r));
+
                 else
                         server_fix_perms(s, s->system_journal, 0);
         }
@@ -346,7 +352,10 @@ static void server_rotate(Server *s) {
         HASHMAP_FOREACH_KEY(f, k, s->user_journals, i) {
                 r = journal_file_rotate(&f);
                 if (r < 0)
-                        log_error("Failed to rotate %s: %s", f->path, strerror(-r));
+                        if (f->path)
+                                log_error("Failed to rotate %s: %s", f->path, strerror(-r));
+                        else
+                                log_error("Failed to create user journal: %s", strerror(-r));
                 else {
                         hashmap_replace(s->user_journals, k, f);
                         server_fix_perms(s, s->system_journal, PTR_TO_UINT32(k));
@@ -609,7 +618,15 @@ retry:
         else {
                 r = journal_file_append_entry(f, NULL, iovec, n, &s->seqnum, NULL, NULL);
 
-                if ((r == -EBADMSG || r == -E2BIG) && !vacuumed) {
+                if ((r == -E2BIG || /* hit limit */
+                     r == -EFBIG || /* hit fs limit */
+                     r == -EDQUOT || /* quota hit */
+                     r == -ENOSPC || /* disk full */
+                     r == -EBADMSG || /* corrupted */
+                     r == -ENODATA || /* truncated */
+                     r == -EHOSTDOWN || /* other machine */
+                     r == -EPROTONOSUPPORT) && /* unsupported feature */
+                    !vacuumed) {
 
                         if (r == -E2BIG)
                                 log_info("Allocation limit reached, rotating.");
@@ -2141,10 +2158,20 @@ static int process_event(Server *s, stru
                         size_t label_len = 0;
                         union {
                                 struct cmsghdr cmsghdr;
+
+                                /* We use NAME_MAX space for the
+                                 * SELinux label here. The kernel
+                                 * currently enforces no limit, but
+                                 * according to suggestions from the
+                                 * SELinux people this will change and
+                                 * it will probably be identical to
+                                 * NAME_MAX. For now we use that, but
+                                 * this should be updated one day when
+                                 * the final limit is known.*/
                                 uint8_t buf[CMSG_SPACE(sizeof(struct ucred)) +
                                             CMSG_SPACE(sizeof(struct timeval)) +
-                                            CMSG_SPACE(sizeof(int)) +
-                                            CMSG_SPACE(PAGE_SIZE)]; /* selinux label */
+                                            CMSG_SPACE(sizeof(int)) + /* fd */
+                                            CMSG_SPACE(NAME_MAX)]; /* selinux label */
                         } control;
                         ssize_t n;
                         int v;
--- systemd-44.orig/src/journal/systemd-journald.conf
+++ systemd-44/src/journal/systemd-journald.conf
@@ -22,4 +22,4 @@
 #ForwardToSyslog=yes
 #ForwardToKMsg=no
 #ForwardToConsole=no
-#ImportKernel=yes
+ImportKernel=no
--- systemd-44.orig/src/login/71-seat.rules
+++ systemd-44/src/login/71-seat.rules
@@ -6,6 +6,7 @@
 #  (at your option) any later version.
 
 ACTION=="remove", GOTO="seat_end"
+TEST!="/sys/fs/cgroup/systemd", GOTO="seat_end"
 
 TAG=="uaccess", SUBSYSTEM!="sound", TAG+="seat"
 SUBSYSTEM=="sound", KERNEL=="card*", TAG+="seat"
--- systemd-44.orig/src/login/73-seat-late.rules.in
+++ systemd-44/src/login/73-seat-late.rules.in
@@ -6,6 +6,7 @@
 #  (at your option) any later version.
 
 ACTION=="remove", GOTO="seat_late_end"
+TEST!="/sys/fs/cgroup/systemd", GOTO="seat_late_end"
 
 ENV{ID_SEAT}=="", ENV{ID_AUTOSEAT}=="1", ENV{ID_FOR_SEAT}!="", ENV{ID_SEAT}="seat-$env{ID_FOR_SEAT}"
 ENV{ID_SEAT}=="", IMPORT{parent}="ID_SEAT"
--- systemd-44.orig/src/login/pam-module.c
+++ systemd-44/src/login/pam-module.c
@@ -340,10 +340,6 @@ _public_ PAM_EXTERN int pam_sm_open_sess
 
         /* pam_syslog(handle, LOG_INFO, "pam-systemd initializing"); */
 
-        /* Make this a NOP on non-systemd systems */
-        if (sd_booted() <= 0)
-                return PAM_SUCCESS;
-
         if (parse_argv(handle,
                        argc, argv,
                        &controllers, &reset_controllers,
--- systemd-44.orig/src/login/logind-session.c
+++ systemd-44/src/login/logind-session.c
@@ -627,7 +627,7 @@ static int session_terminate_cgroup(Sess
 
                         r = manager_get_session_by_pid(s->manager, s->leader, &t);
                         if (r > 0 && t == s) {
-                                kill(s->leader, SIGTERM); /* for normal processes */
+                                /*kill(s->leader, SIGTERM); */ /* for normal processes */
                                 kill(s->leader, SIGHUP);  /* for shells */
                                 kill(s->leader, SIGCONT); /* in case they are stopped */
                         }
--- systemd-44.orig/src/login/70-uaccess.rules
+++ systemd-44/src/login/70-uaccess.rules
@@ -7,6 +7,7 @@
 
 ACTION=="remove", GOTO="uaccess_end"
 ENV{MAJOR}=="", GOTO="uaccess_end"
+TEST!="/sys/fs/cgroup/systemd", GOTO="uaccess_end"
 
 # PTP/MTP protocol devices, cameras, portable media players
 SUBSYSTEM=="usb", ENV{ID_USB_INTERFACES}=="", ENV{DEVTYPE}=="usb_device", IMPORT{program}="usb_id --export %p"
--- systemd-44.orig/src/locale/localed.c
+++ systemd-44/src/locale/localed.c
@@ -73,6 +73,12 @@
         BUS_GENERIC_INTERFACES_LIST             \
         "org.freedesktop.locale1\0"
 
+#ifdef TARGET_DEBIAN
+#define LOCALEFILE "/etc/default/locale"
+#else
+#define LOCALEFILE "/etc/locale.conf"
+#endif
+
 const char locale_interface[] _introspect_("locale1") = INTERFACE;
 
 enum {
@@ -194,7 +200,7 @@ static int read_data_locale(void) {
 
         free_data_locale();
 
-        r = parse_env_file("/etc/locale.conf", NEWLINE,
+        r = parse_env_file(LOCALEFILE, NEWLINE,
                            "LANG",              &data[PROP_LANG],
                            "LANGUAGE",          &data[PROP_LANGUAGE],
                            "LC_CTYPE",          &data[PROP_LC_CTYPE],
@@ -266,9 +272,23 @@ static int read_data_x11(void) {
         FILE *f;
         char line[LINE_MAX];
         bool in_section = false;
+#ifdef TARGET_DEBIAN
+        int r;
+#endif
 
         free_data_x11();
 
+#ifdef TARGET_DEBIAN
+        r = parse_env_file("/etc/default/keyboard", NEWLINE,
+                           "XKBMODEL",          &state.x11_model,
+                           "XKBLAYOUT",         &state.x11_layout,
+                           "XKBVARIANT",        &state.x11_variant,
+                           "XKBOPTIONS",        &state.x11_options,
+                           NULL);
+
+        return r;
+#else
+
         f = fopen("/etc/X11/xorg.conf.d/00-keyboard.conf", "re");
         if (!f) {
                 if (errno == ENOENT) {
@@ -350,6 +370,7 @@ static int read_data_x11(void) {
         fclose(f);
 
         return 0;
+#endif
 }
 
 static int read_data(void) {
@@ -366,7 +387,7 @@ static int write_data_locale(void) {
         int r, p;
         char **l = NULL;
 
-        r = load_env_file("/etc/locale.conf", &l);
+        r = load_env_file(LOCALEFILE, &l);
         if (r < 0 && r != -ENOENT)
                 return r;
 
@@ -398,13 +419,13 @@ static int write_data_locale(void) {
         if (strv_isempty(l)) {
                 strv_free(l);
 
-                if (unlink("/etc/locale.conf") < 0)
+                if (unlink(LOCALEFILE) < 0)
                         return errno == ENOENT ? 0 : -errno;
 
                 return 0;
         }
 
-        r = write_env_file("/etc/locale.conf", l);
+        r = write_env_file(LOCALEFILE, l);
         strv_free(l);
 
         return r;
@@ -571,6 +592,101 @@ static int write_data_x11(void) {
         char *temp_path;
         int r;
 
+#ifdef TARGET_DEBIAN
+        int p;
+        char *t, **u, **l = NULL;
+
+        r = load_env_file("/etc/default/keyboard", &l);
+        if (r < 0 && r != -ENOENT)
+                return r;
+
+        /* This could perhaps be done more elegantly using an array
+         * like we do for the locale, instead of struct
+         */
+        if (isempty(state.x11_layout)) {
+                l = strv_env_unset(l, "XKBLAYOUT");
+        } else {
+                if (asprintf(&t, "XKBLAYOUT=%s", state.x11_layout) < 0) {
+                        strv_free(l);
+                        return -ENOMEM;
+                }
+
+                u = strv_env_set(l, t);
+                free(t);
+                strv_free(l);
+
+                if (!u)
+                        return -ENOMEM;
+
+                l = u;
+        }
+
+        if (isempty(state.x11_model)) {
+                l = strv_env_unset(l, "XKBMODEL");
+        } else {
+                if (asprintf(&t, "XKBMODEL=%s", state.x11_model) < 0) {
+                        strv_free(l);
+                        return -ENOMEM;
+                }
+
+                u = strv_env_set(l, t);
+                free(t);
+                strv_free(l);
+
+                if (!u)
+                        return -ENOMEM;
+
+                l = u;
+        }
+
+        if (isempty(state.x11_variant)) {
+                l = strv_env_unset(l, "XKBVARIANT");
+        } else {
+                if (asprintf(&t, "XKBVARIANT=%s", state.x11_variant) < 0) {
+                        strv_free(l);
+                        return -ENOMEM;
+                }
+
+                u = strv_env_set(l, t);
+                free(t);
+                strv_free(l);
+
+                if (!u)
+                        return -ENOMEM;
+
+                l = u;
+        }
+
+        if (isempty(state.x11_options)) {
+                l = strv_env_unset(l, "XKBOPTIONS");
+        } else {
+                if (asprintf(&t, "XKBOPTIONS=%s", state.x11_options) < 0) {
+                        strv_free(l);
+                        return -ENOMEM;
+                }
+
+                u = strv_env_set(l, t);
+                free(t);
+                strv_free(l);
+
+                if (!u)
+                        return -ENOMEM;
+
+                l = u;
+        }
+
+        if (strv_isempty(l)) {
+                strv_free(l);
+
+                if (unlink("/etc/default/keyboard") < 0)
+                        return errno == ENOENT ? 0 : -errno;
+
+                return 0;
+        }
+
+        r = write_env_file("/etc/default/keyboard", l);
+        strv_free(l);
+#else
         if (isempty(state.x11_layout) &&
             isempty(state.x11_model) &&
             isempty(state.x11_variant) &&
@@ -638,6 +754,7 @@ static int write_data_x11(void) {
 
         fclose(f);
         free(temp_path);
+#endif
 
         return r;
 }
--- systemd-44.orig/src/locale/org.freedesktop.locale1.service
+++ systemd-44/src/locale/org.freedesktop.locale1.service
@@ -7,6 +7,6 @@
 
 [D-BUS Service]
 Name=org.freedesktop.locale1
-Exec=/bin/false
+Exec=/usr/lib/systemd/systemd-localed
 User=root
 SystemdService=dbus-org.freedesktop.locale1.service
--- systemd-44.orig/src/timedate/org.freedesktop.timedate1.service
+++ systemd-44/src/timedate/org.freedesktop.timedate1.service
@@ -7,6 +7,6 @@
 
 [D-BUS Service]
 Name=org.freedesktop.timedate1
-Exec=/bin/false
+Exec=/usr/lib/systemd/systemd-timedated
 User=root
 SystemdService=dbus-org.freedesktop.timedate1.service
--- systemd-44.orig/src/hostname/org.freedesktop.hostname1.service
+++ systemd-44/src/hostname/org.freedesktop.hostname1.service
@@ -7,6 +7,6 @@
 
 [D-BUS Service]
 Name=org.freedesktop.hostname1
-Exec=/bin/false
+Exec=/usr/lib/systemd/systemd-hostnamed
 User=root
 SystemdService=dbus-org.freedesktop.hostname1.service
--- systemd-44.orig/units/remount-rootfs.service
+++ systemd-44/units/remount-rootfs.service
@@ -10,7 +10,7 @@ Description=Remount Root FS
 DefaultDependencies=no
 Conflicts=shutdown.target
 After=systemd-readahead-collect.service systemd-readahead-replay.service fsck-root.service
-Before=local-fs-pre.target local-fs.target shutdown.target
+Before=local-fs-pre.target local-fs.target shutdown.target mountoverflowtmp.service
 Wants=local-fs-pre.target
 
 [Service]
--- systemd-44.orig/units/remote-fs.target
+++ systemd-44/units/remote-fs.target
@@ -9,6 +9,7 @@
 
 [Unit]
 Description=Remote File Systems
+After=local-fs.target
 
 [Install]
 WantedBy=multi-user.target
--- systemd-44.orig/tmpfiles.d/tmp.conf
+++ systemd-44/tmpfiles.d/tmp.conf
@@ -8,5 +8,5 @@
 # See tmpfiles.d(5) for details
 
 # Clear tmp directories separately, to make them easier to override
-d /tmp 1777 root root 10d
-d /var/tmp 1777 root root 30d
+D /tmp 1777 root root -
+#d /var/tmp 1777 root root 30d
--- systemd-44.orig/tmpfiles.d/legacy.conf
+++ systemd-44/tmpfiles.d/legacy.conf
@@ -17,6 +17,6 @@
 # On modern systems a BSD file lock is a better choice if
 # serialization is needed on those devices.
 
-d /run/lock 0755 root root -
+d /run/lock 1777 root root -
 d /run/lock/subsys 0755 root root -
-d /run/lock/lockdev 0775 root lock -
+d /run/lock/lockdev 0775 root root -
