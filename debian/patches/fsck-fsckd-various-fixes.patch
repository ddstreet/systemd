From: Martin Pitt <martin.pitt@ubuntu.com>
Date: Tue, 3 Mar 2015 00:02:31 -0500
Subject: fsck, fsckd: various fixes

Various fixes to fsck and fsckd from upstream git.

LP: #1429171
---
 src/fsck/fsck.c   |  83 +++++------
 src/fsckd/fsckd.c | 420 +++++++++++++++++++++++++++++++++---------------------
 2 files changed, 297 insertions(+), 206 deletions(-)

diff --git a/src/fsck/fsck.c b/src/fsck/fsck.c
index e718534..d1c3a8c 100644
--- a/src/fsck/fsck.c
+++ b/src/fsck/fsck.c
@@ -161,7 +161,7 @@ static int process_progress(int fd, pid_t fsck_pid, dev_t device_num) {
                 FsckProgress progress;
                 FsckdMessage fsckd_message;
 
-                if (fscanf(f, "%i %lu %lu %ms", &pass, &cur, &max, &device) != 4)
+                if (fscanf(f, "%i %zu %zu %ms", &pass, &cur, &max, &device) != 4)
                         break;
 
                 /* Only update once every 50ms */
@@ -205,7 +205,7 @@ int main(int argc, char *argv[]) {
         _cleanup_udev_device_unref_ struct udev_device *udev_device = NULL;
         const char *device, *type;
         bool root_directory;
-        int progress_pipe[2] = { -1, -1 };
+        _cleanup_close_pair_ int progress_pipe[2] = { -1, -1 };
         char dash_c[sizeof("-C")-1 + DECIMAL_STR_MAX(int) + 1];
         struct stat st;
 
@@ -226,13 +226,15 @@ int main(int argc, char *argv[]) {
 
         test_files();
 
-        if (!arg_force && arg_skip)
-                return 0;
+        if (!arg_force && arg_skip) {
+                r = 0;
+                goto finish;
+        }
 
         udev = udev_new();
         if (!udev) {
-                log_oom();
-                return EXIT_FAILURE;
+                r = log_oom();
+                goto finish;
         }
 
         if (argc > 1) {
@@ -240,14 +242,14 @@ int main(int argc, char *argv[]) {
                 root_directory = false;
 
                 if (stat(device, &st) < 0) {
-                        log_error_errno(errno, "Failed to stat '%s': %m", device);
-                        return EXIT_FAILURE;
+                        r = log_error_errno(errno, "Failed to stat '%s': %m", device);
+                        goto finish;
                 }
 
                 udev_device = udev_device_new_from_devnum(udev, 'b', st.st_rdev);
                 if (!udev_device) {
-                        log_error("Failed to detect device %s", device);
-                        return EXIT_FAILURE;
+                        r = log_error_errno(errno, "Failed to detect device %s", device);
+                        goto finish;
                 }
         } else {
                 struct timespec times[2];
@@ -255,32 +257,37 @@ int main(int argc, char *argv[]) {
                 /* Find root device */
 
                 if (stat("/", &st) < 0) {
-                        log_error_errno(errno, "Failed to stat() the root directory: %m");
-                        return EXIT_FAILURE;
+                        r = log_error_errno(errno, "Failed to stat() the root directory: %m");
+                        goto finish;
                 }
 
                 /* Virtual root devices don't need an fsck */
-                if (major(st.st_dev) == 0)
-                        return EXIT_SUCCESS;
+                if (major(st.st_dev) == 0) {
+                        log_debug("Root directory is virtual, skipping check.");
+                        r = 0;
+                        goto finish;
+                }
 
                 /* check if we are already writable */
                 times[0] = st.st_atim;
                 times[1] = st.st_mtim;
                 if (utimensat(AT_FDCWD, "/", times, 0) == 0) {
                         log_info("Root directory is writable, skipping check.");
-                        return EXIT_SUCCESS;
+                        r = 0;
+                        goto finish;
                 }
 
                 udev_device = udev_device_new_from_devnum(udev, 'b', st.st_dev);
                 if (!udev_device) {
-                        log_error("Failed to detect root device.");
-                        return EXIT_FAILURE;
+                        r = log_error_errno(errno, "Failed to detect root device.");
+                        goto finish;
                 }
 
                 device = udev_device_get_devnode(udev_device);
                 if (!device) {
                         log_error("Failed to detect device node of root directory.");
-                        return EXIT_FAILURE;
+                        r = -ENXIO;
+                        goto finish;
                 }
 
                 root_directory = true;
@@ -291,14 +298,15 @@ int main(int argc, char *argv[]) {
                 r = fsck_exists(type);
                 if (r == -ENOENT) {
                         log_info("fsck.%s doesn't exist, not checking file system on %s", type, device);
-                        return EXIT_SUCCESS;
+                        r = 0;
+                        goto finish;
                 } else if (r < 0)
                         log_warning_errno(r, "fsck.%s cannot be used for %s: %m", type, device);
         }
 
         if (pipe(progress_pipe) < 0) {
-                log_error_errno(errno, "pipe(): %m");
-                return EXIT_FAILURE;
+                r = log_error_errno(errno, "pipe(): %m");
+                goto finish;
         }
 
         cmdline[i++] = "/sbin/fsck";
@@ -318,36 +326,31 @@ int main(int argc, char *argv[]) {
         if (arg_force)
                 cmdline[i++] = "-f";
 
-        if (progress_pipe[1] >= 0) {
-                xsprintf(dash_c, "-C%i", progress_pipe[1]);
-                cmdline[i++] = dash_c;
-        }
+        xsprintf(dash_c, "-C%i", progress_pipe[1]);
+        cmdline[i++] = dash_c;
 
         cmdline[i++] = device;
         cmdline[i++] = NULL;
 
         pid = fork();
         if (pid < 0) {
-                log_error_errno(errno, "fork(): %m");
+                r = log_error_errno(errno, "fork(): %m");
                 goto finish;
         } else if (pid == 0) {
                 /* Child */
-                if (progress_pipe[0] >= 0)
-                        safe_close(progress_pipe[0]);
+                progress_pipe[0] = safe_close(progress_pipe[0]);
                 execv(cmdline[0], (char**) cmdline);
                 _exit(8); /* Operational error */
         }
 
         progress_pipe[1] = safe_close(progress_pipe[1]);
 
-        if (progress_pipe[0] >= 0) {
-                progress_rc = process_progress(progress_pipe[0], pid, st.st_rdev);
-                progress_pipe[0] = -1;
-        }
+        progress_rc = process_progress(progress_pipe[0], pid, st.st_rdev);
+        progress_pipe[0] = -1;
 
-        q = wait_for_terminate(pid, &status);
-        if (q < 0) {
-                log_error_errno(q, "waitid(): %m");
+        r = wait_for_terminate(pid, &status);
+        if (r < 0) {
+                log_error_errno(r, "waitid(): %m");
                 goto finish;
         }
 
@@ -361,6 +364,8 @@ int main(int argc, char *argv[]) {
                 else if (progress_rc != 0)
                         log_error("fsck failed due to unknown reason.");
 
+                r = -EINVAL;
+
                 if (status.si_code == CLD_EXITED && (status.si_status & 2) && root_directory)
                         /* System should be rebooted. */
                         start_target(SPECIAL_REBOOT_TARGET);
@@ -368,19 +373,17 @@ int main(int argc, char *argv[]) {
                         /* Some other problem */
                         start_target(SPECIAL_EMERGENCY_TARGET);
                 else {
-                        r = EXIT_SUCCESS;
+                        r = 0;
                         if (progress_rc != 0)
                                 log_warning("Ignoring error.");
                 }
 
         } else
-                r = EXIT_SUCCESS;
+                r = 0;
 
         if (status.si_code == CLD_EXITED && (status.si_status & 1))
                 touch("/run/systemd/quotacheck");
 
 finish:
-        safe_close_pair(progress_pipe);
-
-        return r;
+        return r < 0 ? EXIT_FAILURE : EXIT_SUCCESS;
 }
diff --git a/src/fsckd/fsckd.c b/src/fsckd/fsckd.c
index 834476c..6b35fc2 100644
--- a/src/fsckd/fsckd.c
+++ b/src/fsckd/fsckd.c
@@ -34,19 +34,20 @@
 #include <sys/un.h>
 #include <unistd.h>
 
+#include "sd-daemon.h"
 #include "build.h"
 #include "def.h"
 #include "event-util.h"
-#include "fsckd.h"
 #include "log.h"
 #include "list.h"
 #include "macro.h"
-#include "sd-daemon.h"
 #include "socket-util.h"
 #include "util.h"
+#include "fsckd.h"
 
 #define IDLE_TIME_SECONDS 30
 #define PLYMOUTH_REQUEST_KEY "K\2\2\3"
+#define CLIENTS_MAX 128
 
 struct Manager;
 
@@ -54,34 +55,79 @@ typedef struct Client {
         struct Manager *manager;
         int fd;
         dev_t devnum;
+
         size_t cur;
         size_t max;
         int pass;
+
         double percent;
+
         size_t buflen;
         bool cancelled;
 
+        sd_event_source *event_source;
+
         LIST_FIELDS(struct Client, clients);
 } Client;
 
 typedef struct Manager {
         sd_event *event;
-        Client *clients;
-        int clear;
+
+        LIST_HEAD(Client, clients);
+        unsigned n_clients;
+
+        size_t clear;
+
         int connection_fd;
-        FILE *console;
+        sd_event_source *connection_event_source;
+
+        bool show_status_console;
+
         double percent;
         int numdevices;
+
         int plymouth_fd;
+        sd_event_source *plymouth_event_source;
         bool plymouth_cancel_sent;
+
         bool cancel_requested;
 } Manager;
 
-static int connect_plymouth(Manager *m);
-static int update_global_progress(Manager *m);
+static void client_free(Client *c);
 static void manager_free(Manager *m);
+
+DEFINE_TRIVIAL_CLEANUP_FUNC(Client*, client_free);
 DEFINE_TRIVIAL_CLEANUP_FUNC(Manager*, manager_free);
-#define _cleanup_manager_free_ _cleanup_(manager_freep)
+
+static int manager_write_console(Manager *m, const char *message) {
+        _cleanup_fclose_ FILE *console = NULL;
+        int l;
+        size_t j;
+
+        assert(m);
+
+        if (!m->show_status_console)
+                return 0;
+
+        /* Reduce the SAK window by opening and closing console on every request */
+        console = fopen("/dev/console", "we");
+        if (!console)
+                return -errno;
+
+        if (message) {
+                fprintf(console, "\r%s\r%n", message, &l);
+                if (m->clear  < (size_t)l)
+                        m->clear = (size_t)l;
+        } else {
+                fputc('\r', console);
+                for (j = 0; j < m->clear; j++)
+                        fputc(' ', console);
+                fputc('\r', console);
+        }
+        fflush(console);
+
+        return 0;
+}
 
 static double compute_percent(int pass, size_t cur, size_t max) {
         /* Values stolen from e2fsck */
@@ -101,62 +147,122 @@ static double compute_percent(int pass, size_t cur, size_t max) {
                 (double) cur / max;
 }
 
-static int request_cancel_client(Client *current) {
-        FsckdMessage cancel_msg;
+static int client_request_cancel(Client *c) {
+        FsckdMessage cancel_msg = {
+                .cancel = 1,
+        };
+
         ssize_t n;
-        cancel_msg.cancel = 1;
-
-        n = send(current->fd, &cancel_msg, sizeof(FsckdMessage), 0);
-        if (n < 0 || (size_t) n < sizeof(FsckdMessage))
-                return log_warning_errno(n, "Cannot send cancel to fsck on (%u, %u): %m",
-                                         major(current->devnum), minor(current->devnum));
-        else
-                current->cancelled = true;
-        return 0;
+
+        assert(c);
+
+        if (c->cancelled)
+                return 0;
+
+        n = send(c->fd, &cancel_msg, sizeof(FsckdMessage), 0);
+        if (n < 0)
+                return log_warning_errno(errno, "Cannot send cancel to fsck on (%u:%u): %m", major(c->devnum), minor(c->devnum));
+        if ((size_t) n < sizeof(FsckdMessage)) {
+                log_warning("Short send when sending cancel to fsck on (%u:%u).", major(c->devnum), minor(c->devnum));
+                return -EIO;
+        }
+
+        c->cancelled = true;
+        return 1;
 }
 
-static void remove_client(Client **first, Client *item) {
-        LIST_REMOVE(clients, *first, item);
-        safe_close(item->fd);
-        free(item);
+static void client_free(Client *c) {
+        assert(c);
+
+        if (c->manager) {
+                LIST_REMOVE(clients, c->manager->clients, c);
+                c->manager->n_clients--;
+        }
+
+        sd_event_source_unref(c->event_source);
+
+        safe_close(c->fd);
+        free(c);
 }
 
-static void on_plymouth_disconnect(Manager *m) {
-        safe_close(m->plymouth_fd);
-        m->plymouth_fd = -1;
+static void manager_disconnect_plymouth(Manager *m) {
+        assert(m);
+
+        m->plymouth_event_source = sd_event_source_unref(m->plymouth_event_source);
+        m->plymouth_fd = safe_close(m->plymouth_fd);
         m->plymouth_cancel_sent = false;
 }
 
-static int plymouth_feedback_handler(sd_event_source *s, int fd, uint32_t revents, void *userdata) {
+static int manager_plymouth_feedback_handler(sd_event_source *s, int fd, uint32_t revents, void *userdata) {
         Manager *m = userdata;
         Client *current;
         char buffer[6];
-        int r;
+        ssize_t l;
 
         assert(m);
 
-        r = read(m->plymouth_fd, buffer, sizeof(buffer));
-        if (r <= 0)
-                on_plymouth_disconnect(m);
-        else {
-               if (buffer[0] == '\15')
-                       log_error("Message update to plymouth wasn't delivered successfully");
-
-               /* the only answer support type we requested is a key interruption */
-               if (buffer[0] == '\2' && buffer[5] == '\3') {
-                       m->cancel_requested = true;
-                       /* cancel all connected clients */
-                       LIST_FOREACH(clients, current, m->clients)
-                               request_cancel_client(current);
-               }
+        l = read(m->plymouth_fd, buffer, sizeof(buffer));
+        if (l < 0) {
+                log_warning_errno(errno, "Got error while reading from plymouth: %m");
+                manager_disconnect_plymouth(m);
+                return -errno;
+        }
+        if (l == 0) {
+                manager_disconnect_plymouth(m);
+                return 0;
+        }
+
+        if (l > 1 && buffer[0] == '\15')
+                log_error("Message update to plymouth wasn't delivered successfully");
+
+        /* the only answer support type we requested is a key interruption */
+        if (l > 2 && buffer[0] == '\2' && buffer[5] == '\3') {
+                m->cancel_requested = true;
+
+                /* cancel all connected clients */
+                LIST_FOREACH(clients, current, m->clients)
+                        client_request_cancel(current);
         }
 
         return 0;
 }
 
-static int send_message_plymouth_socket(int plymouth_fd, const char *message, bool update) {
+static int manager_connect_plymouth(Manager *m) {
+        union sockaddr_union sa = PLYMOUTH_SOCKET;
+        int r;
+
+        if (!plymouth_running())
+                return 0;
+
+        /* try to connect or reconnect if sending a message */
+        if (m->plymouth_fd >= 0)
+                return 1;
+
+        m->plymouth_fd = socket(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC, 0);
+        if (m->plymouth_fd < 0)
+                return log_warning_errno(errno, "Connection to plymouth socket failed: %m");
+
+        if (connect(m->plymouth_fd, &sa.sa, offsetof(struct sockaddr_un, sun_path) + 1 + strlen(sa.un.sun_path+1)) < 0) {
+                r = log_warning_errno(errno, "Couldn't connect to plymouth: %m");
+                goto fail;
+        }
+
+        r = sd_event_add_io(m->event, &m->plymouth_event_source, m->plymouth_fd, EPOLLIN, manager_plymouth_feedback_handler, m);
+        if (r < 0) {
+                log_warning_errno(r, "Can't listen to plymouth socket: %m");
+                goto fail;
+        }
+
+        return 1;
+
+fail:
+        manager_disconnect_plymouth(m);
+        return r;
+}
+
+static int plymouth_send_message(int plymouth_fd, const char *message, bool update) {
         _cleanup_free_ char *packet = NULL;
-        int r, n;
+        int n;
         char mode = 'M';
 
         if (update)
@@ -164,48 +270,58 @@ static int send_message_plymouth_socket(int plymouth_fd, const char *message, bo
 
         if (asprintf(&packet, "%c\002%c%s%n", mode, (int) (strlen(message) + 1), message, &n) < 0)
                 return log_oom();
-        r = loop_write(plymouth_fd, packet, n + 1, true);
-        return r;
-}
 
+        return loop_write(plymouth_fd, packet, n + 1, true);
+}
 
-static int send_message_plymouth(Manager *m, const char *message) {
+static int manager_send_plymouth_message(Manager *m, const char *message) {
+        const char *plymouth_cancel_message = NULL, *l10n_cancel_message = NULL;
         int r;
-        const char *plymouth_cancel_message = NULL;
 
-        r = connect_plymouth(m);
+        r = manager_connect_plymouth(m);
         if (r < 0)
                 return r;
+        /* 0 means that plymouth isn't running, do not send any message yet */
+        else if (r == 0)
+                return 0;
 
         if (!m->plymouth_cancel_sent) {
-                /* indicate to plymouth that we listen to Ctrl+C */
+
+                /* Indicate to plymouth that we listen to Ctrl+C */
                 r = loop_write(m->plymouth_fd, PLYMOUTH_REQUEST_KEY, sizeof(PLYMOUTH_REQUEST_KEY), true);
                 if (r < 0)
-                        return log_warning_errno(errno, "Can't send to plymouth cancel key: %m");
+                        return log_warning_errno(r, "Can't send to plymouth cancel key: %m");
+
                 m->plymouth_cancel_sent = true;
-                plymouth_cancel_message = strjoina("fsckd-cancel-msg:", _("Press Ctrl+C to cancel all filesystem checks in progress"));
-                r = send_message_plymouth_socket(m->plymouth_fd, plymouth_cancel_message, false);
+
+                l10n_cancel_message = _("Press Ctrl+C to cancel all filesystem checks in progress");
+                plymouth_cancel_message = strjoina("fsckd-cancel-msg:", l10n_cancel_message);
+
+                r = plymouth_send_message(m->plymouth_fd, plymouth_cancel_message, false);
                 if (r < 0)
                         log_warning_errno(r, "Can't send filesystem cancel message to plymouth: %m");
+
         } else if (m->numdevices == 0) {
+
                 m->plymouth_cancel_sent = false;
-                r = send_message_plymouth_socket(m->plymouth_fd, "", false);
+
+                r = plymouth_send_message(m->plymouth_fd, "", false);
                 if (r < 0)
                         log_warning_errno(r, "Can't clear plymouth filesystem cancel message: %m");
         }
 
-        r = send_message_plymouth_socket(m->plymouth_fd,  message, true);
+        r = plymouth_send_message(m->plymouth_fd,  message, true);
         if (r < 0)
-                return log_warning_errno(errno, "Couldn't send \"%s\" to plymouth: %m", message);
+                return log_warning_errno(r, "Couldn't send \"%s\" to plymouth: %m", message);
 
         return 0;
 }
 
-static int update_global_progress(Manager *m) {
+static int manager_update_global_progress(Manager *m) {
         Client *current = NULL;
         _cleanup_free_ char *console_message = NULL;
         _cleanup_free_ char *fsck_message = NULL;
-        int current_numdevices = 0, l = 0, r;
+        int current_numdevices = 0, r;
         double current_percent = 100;
 
         /* get the overall percentage */
@@ -228,65 +344,36 @@ static int update_global_progress(Manager *m) {
                                       "Checking in progress on %d disks (%3.1f%% complete)", m->numdevices),
                                       m->numdevices, m->percent) < 0)
                         return -ENOMEM;
+
                 if (asprintf(&fsck_message, "fsckd:%d:%3.1f:%s", m->numdevices, m->percent, console_message) < 0)
                         return -ENOMEM;
 
-                /* write to console */
-                if (m->console) {
-                        fprintf(m->console, "\r%s\r%n", console_message, &l);
-                        fflush(m->console);
-                }
+                r = manager_write_console(m, console_message);
+                if (r < 0)
+                        return r;
 
                 /* try to connect to plymouth and send message */
-                r = send_message_plymouth(m, fsck_message);
+                r = manager_send_plymouth_message(m, fsck_message);
                 if (r < 0)
-                        log_debug("Couldn't send message to plymouth");
-
-                if (l > m->clear)
-                        m->clear = l;
-        }
-        return 0;
-}
-
-static int connect_plymouth(Manager *m) {
-        union sockaddr_union sa = PLYMOUTH_SOCKET;
-        int r;
-
-        /* try to connect or reconnect if sending a message */
-        if (m->plymouth_fd <= 0) {
-                m->plymouth_fd = socket(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC, 0);
-                if (m->plymouth_fd < 0) {
-                        return log_warning_errno(errno, "Connection to plymouth socket failed: %m");
-                }
-                if (connect(m->plymouth_fd, &sa.sa, offsetof(struct sockaddr_un, sun_path) + 1 + strlen(sa.un.sun_path+1)) < 0) {
-                        on_plymouth_disconnect(m);
-                        return log_warning_errno(errno, "Couldn't connect to plymouth: %m");
-                }
-                r = sd_event_add_io(m->event, NULL, m->plymouth_fd, EPOLLIN, plymouth_feedback_handler, m);
-                if (r < 0) {
-                        on_plymouth_disconnect(m);
-                        return log_warning_errno(r, "Can't listen to plymouth socket: %m");
-                }
+                        return r;
         }
-
         return 0;
 }
 
-static int progress_handler(sd_event_source *s, int fd, uint32_t revents, void *userdata) {
+static int client_progress_handler(sd_event_source *s, int fd, uint32_t revents, void *userdata) {
         Client *client = userdata;
-        Manager *m = NULL;
         FsckProgress fsck_data;
         size_t buflen;
+        Manager *m;
         int r;
 
         assert(client);
+
         m = client->manager;
 
         /* check first if we need to cancel this client */
-        if (m->cancel_requested) {
-                if (!client->cancelled)
-                        request_cancel_client(client);
-        }
+        if (m->cancel_requested)
+                client_request_cancel(client);
 
         /* ensure we have enough data to read */
         r = ioctl(fd, FIONREAD, &buflen);
@@ -296,10 +383,8 @@ static int progress_handler(sd_event_source *s, int fd, uint32_t revents, void *
                 /* we got twice the same size from a bad behaving client, kick it off the list */
                 else {
                         log_warning("Closing bad behaving fsck client connection at fd %d", client->fd);
-                        remove_client(&(m->clients), client);
-                        r = update_global_progress(m);
-                        if (r < 0)
-                                log_warning_errno(r, "Couldn't update global progress: %m");
+                        client_free(client);
+                        manager_update_global_progress(m);
                 }
                 return 0;
         }
@@ -308,7 +393,7 @@ static int progress_handler(sd_event_source *s, int fd, uint32_t revents, void *
         r = recv(fd, &fsck_data, sizeof(FsckProgress), 0);
         if (r == 0) {
                 log_debug("Fsck client connected to fd %d disconnected", client->fd);
-                remove_client(&(m->clients), client);
+                client_free(client);
         } else if (r > 0 && r != sizeof(FsckProgress))
                 log_warning("Unexpected data structure sent to fsckd socket from fd: %d. Ignoring", client->fd);
         else if (r > 0 && r == sizeof(FsckProgress)) {
@@ -323,67 +408,72 @@ static int progress_handler(sd_event_source *s, int fd, uint32_t revents, void *
         } else
                 log_error_errno(r, "Unknown error while trying to read fsck data: %m");
 
-        r = update_global_progress(m);
-        if (r < 0)
-                log_warning_errno(r, "Couldn't update global progress: %m");
+        manager_update_global_progress(m);
 
         return 0;
 }
 
-static int new_connection_handler(sd_event_source *s, int fd, uint32_t revents, void *userdata) {
+static int manager_new_connection_handler(sd_event_source *s, int fd, uint32_t revents, void *userdata) {
+        _cleanup_(client_freep) Client *c = NULL;
+        _cleanup_close_ int new_client_fd = -1;
         Manager *m = userdata;
-        Client *client = NULL;
-        int new_client_fd, r;
+        int r;
 
         assert(m);
 
         /* Initialize and list new clients */
         new_client_fd = accept4(m->connection_fd, NULL, NULL, SOCK_CLOEXEC);
-        if (new_client_fd > 0) {
-                log_debug("New fsck client connected to fd: %d", new_client_fd);
-                client = new0(Client, 1);
-                if (!client)
-                        return log_oom();
-                client->fd = new_client_fd;
-                client->manager = m;
-                LIST_PREPEND(clients, m->clients, client);
-                r = sd_event_add_io(m->event, NULL, client->fd, EPOLLIN, progress_handler, client);
-                if (r < 0) {
-                        remove_client(&(m->clients), client);
-                        return r;
-                }
-                /* only request the client to cancel now in case the request is dropped by the client (chance to recancel) */
-                if (m->cancel_requested)
-                        request_cancel_client(client);
-        } else
+        if (new_client_fd < 0)
                 return log_error_errno(errno, "Couldn't accept a new connection: %m");
 
+        if (m->n_clients >= CLIENTS_MAX) {
+                log_error("Too many clients, refusing connection.");
+                return 0;
+        }
+
+        log_debug("New fsck client connected to fd: %d", new_client_fd);
+
+        c = new0(Client, 1);
+        if (!c) {
+                log_oom();
+                return 0;
+        }
+
+        c->fd = new_client_fd;
+        new_client_fd = -1;
+
+        r = sd_event_add_io(m->event, &c->event_source, c->fd, EPOLLIN, client_progress_handler, c);
+        if (r < 0) {
+                log_oom();
+                return 0;
+        }
+
+        LIST_PREPEND(clients, m->clients, c);
+        m->n_clients++;
+        c->manager = m;
+
+        /* only request the client to cancel now in case the request is dropped by the client (chance to recancel) */
+        if (m->cancel_requested)
+                client_request_cancel(c);
+
+        c = NULL;
         return 0;
 }
 
 static void manager_free(Manager *m) {
-        Client *current = NULL, *l = NULL;
         if (!m)
                 return;
 
         /* clear last line */
-        if (m->console && m->clear > 0) {
-                unsigned j;
-
-                fputc('\r', m->console);
-                for (j = 0; j < (unsigned) m->clear; j++)
-                        fputc(' ', m->console);
-                fputc('\r', m->console);
-                fflush(m->console);
-        }
+        manager_write_console(m, NULL);
 
+        sd_event_source_unref(m->connection_event_source);
         safe_close(m->connection_fd);
-        safe_close(m->plymouth_fd);
-        if (m->console)
-                fclose(m->console);
 
-        LIST_FOREACH_SAFE(clients, current, l, m->clients)
-                remove_client(&(m->clients), current);
+        while (m->clients)
+                client_free(m->clients);
+
+        manager_disconnect_plymouth(m);
 
         sd_event_unref(m->event);
 
@@ -391,7 +481,7 @@ static void manager_free(Manager *m) {
 }
 
 static int manager_new(Manager **ret, int fd) {
-        _cleanup_manager_free_ Manager *m = NULL;
+        _cleanup_(manager_freep) Manager *m = NULL;
         int r;
 
         assert(ret);
@@ -400,19 +490,21 @@ static int manager_new(Manager **ret, int fd) {
         if (!m)
                 return -ENOMEM;
 
+        m->plymouth_fd = -1;
+        m->connection_fd = fd;
+        m->percent = 100;
+
         r = sd_event_default(&m->event);
         if (r < 0)
                 return r;
 
-        m->connection_fd = fd;
-        if (access("/run/systemd/show-status", F_OK) >= 0) {
-                m->console = fopen("/dev/console", "we");
-                if (!m->console)
-                        return log_warning_errno(errno, "Can't connect to /dev/console: %m");
-        }
-        m->percent = 100;
+        if (access("/run/systemd/show-status", F_OK) >= 0)
+                m->show_status_console = true;
+
+        r = sd_event_add_io(m->event, &m->connection_event_source, fd, EPOLLIN, manager_new_connection_handler, m);
+        if (r < 0)
+                return r;
 
-        m->plymouth_fd = -1;
         *ret = m;
         m = NULL;
 
@@ -503,7 +595,7 @@ static int parse_argv(int argc, char *argv[]) {
 }
 
 int main(int argc, char *argv[]) {
-        _cleanup_manager_free_ Manager *m = NULL;
+        _cleanup_(manager_freep) Manager *m = NULL;
         int fd = -1;
         int r, n;
 
@@ -514,41 +606,37 @@ int main(int argc, char *argv[]) {
 
         r = parse_argv(argc, argv);
         if (r <= 0)
-                return r < 0 ? EXIT_FAILURE : EXIT_SUCCESS;
+                goto finish;
 
         n = sd_listen_fds(0);
         if (n > 1) {
                 log_error("Too many file descriptors received.");
-                return EXIT_FAILURE;
-        } else if (n == 1) {
+                r = -EINVAL;
+                goto finish;
+        } else if (n == 1)
                 fd = SD_LISTEN_FDS_START + 0;
-        } else {
+        else {
                 fd = make_socket_fd(LOG_DEBUG, FSCKD_SOCKET_PATH, SOCK_STREAM | SOCK_CLOEXEC);
                 if (fd < 0) {
-                        log_error_errno(r, "Couldn't create listening socket fd on %s: %m", FSCKD_SOCKET_PATH);
-                        return EXIT_FAILURE;
+                        r = log_error_errno(fd, "Couldn't create listening socket fd on %s: %m", FSCKD_SOCKET_PATH);
+                        goto finish;
                 }
         }
 
         r = manager_new(&m, fd);
         if (r < 0) {
                 log_error_errno(r, "Failed to allocate manager: %m");
-                return EXIT_FAILURE;
-        }
-
-        r = sd_event_add_io(m->event, NULL, fd, EPOLLIN, new_connection_handler, m);
-        if (r < 0) {
-                log_error_errno(r, "Can't listen to connection socket: %m");
-                return EXIT_FAILURE;
+                goto finish;
         }
 
         r = run_event_loop_with_timeout(m->event, IDLE_TIME_SECONDS * USEC_PER_SEC);
         if (r < 0) {
                 log_error_errno(r, "Failed to run event loop: %m");
-                return EXIT_FAILURE;
+                goto finish;
         }
 
         sd_event_get_exit_code(m->event, &r);
 
+finish:
         return r < 0 ? EXIT_FAILURE : EXIT_SUCCESS;
 }
