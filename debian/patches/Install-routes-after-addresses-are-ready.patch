From 1e0a809206c7ccafac697d0aac74aaffe73e80d0 Mon Sep 17 00:00:00 2001
From: Daniel Axtens <dja@axtens.net>
Date: Wed, 5 Dec 2018 21:49:35 +1100
Subject: Install routes after addresses are ready

If an IPv6 route is added with a source address that is still
tentative, the kernel will refuse to install it.

Previously, once we sent the messages to the kernel to add the
addresses, we would immediately proceed to add the routes. The
addresses would usually still be tentative at this point, so
adding static IPv6 routes was broken - see issue #5882.

Now, only begin to configure routes once the addresses are ready,
by restructuring the state machine, and tracking when addresses are
ready, not just added.

Fixes: #5882

Author: Daniel Axtens <daniel.axtens@canonical.com>
Original-Author: Daniel Axtens <dja@axtens.net>
Origin: backport, https://github.com/systemd/systemd/commit/6aa5773bfff0a92d64da70426cae833df6f84daf
Bug-Ubuntu: https://bugs.launchpad.net/bugs/1812760
Last-Update: 2019-01-23
---
 src/network/networkd-link.c | 21 +++++++++++++--------
 src/network/networkd-link.h |  2 ++
 2 files changed, 15 insertions(+), 8 deletions(-)

diff --git a/src/network/networkd-link.c b/src/network/networkd-link.c
index c4f8d6fc0cfa..99d6dda91503 100644
--- a/src/network/networkd-link.c
+++ b/src/network/networkd-link.c
@@ -838,6 +838,15 @@ void link_check_ready(Link *link) {
         if (!link->network)
                 return;
 
+        SET_FOREACH(a, link->addresses, i)
+                if (!address_is_ready(a))
+                        return;
+
+        if (!link->addresses_ready) {
+                link->addresses_ready = true;
+                link_enter_set_routes(link);
+        }
+
         if (!link->static_routes_configured)
                 return;
 
@@ -869,10 +878,6 @@ void link_check_ready(Link *link) {
                                 return;
         }
 
-        SET_FOREACH(a, link->addresses, i)
-                if (!address_is_ready(a))
-                        return;
-
         if (link->state != LINK_STATE_CONFIGURED)
                 link_enter_configured(link);
 
@@ -922,7 +927,7 @@ static int address_handler(sd_netlink *rtnl, sd_netlink_message *m, void *userda
 
         if (link->address_messages == 0) {
                 log_link_debug(link, "Addresses set");
-                link_enter_set_routes(link);
+                link_check_ready(link);
         }
 
         return 1;
@@ -1222,9 +1227,9 @@ static int link_enter_set_addresses(Link *link) {
                 log_link_debug(link, "Offering DHCPv4 leases");
         }
 
-        if (link->address_messages == 0)
-                link_enter_set_routes(link);
-        else
+        if (link->address_messages == 0) {
+                link_check_ready(link);
+        } else
                 log_link_debug(link, "Setting addresses");
 
         return 0;
diff --git a/src/network/networkd-link.h b/src/network/networkd-link.h
index 7e22dfd504ac..01d85a20cdac 100644
--- a/src/network/networkd-link.h
+++ b/src/network/networkd-link.h
@@ -80,6 +80,8 @@ typedef struct Link {
         Set *routes;
         Set *routes_foreign;
 
+        bool addresses_ready;
+
         sd_dhcp_client *dhcp_client;
         sd_dhcp_lease *dhcp_lease;
         char *lease_file;
-- 
2.17.1

