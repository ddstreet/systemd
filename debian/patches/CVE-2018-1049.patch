Backport of:

From e7d54bf58789545a9eb0b3964233defa0b007318 Mon Sep 17 00:00:00 2001
From: Anchor Cat <githubanchorcat@anchor.net.au>
Date: Wed, 10 May 2017 21:23:58 +1000
Subject: [PATCH] automount: ack automount requests even when already mounted
 (#5916)

If a process accesses an autofs filesystem while systemd is in the
middle of starting the mount unit on top of it, it is possible for the
autofs_ptype_missing_direct request from the kernel to be received after
the mount unit has been fully started:

  systemd forks and execs mount             ...
            ...                     access autofs, blocks
  mount exits                               ...
  systemd receives SIGCHLD                  ...
            ...                     kernel sends request
  systemd receives request                  ...

systemd needs to respond to this request, otherwise the kernel will
continue to block access to the mount point.
---
 src/core/automount.c | 33 ++++++++++++++++++---------------
 1 file changed, 18 insertions(+), 15 deletions(-)

Index: systemd-204/src/core/automount.c
===================================================================
--- systemd-204.orig/src/core/automount.c	2018-02-01 07:52:13.746962884 -0500
+++ systemd-204/src/core/automount.c	2018-02-01 08:10:53.228380576 -0500
@@ -582,7 +582,7 @@ fail:
         automount_enter_dead(a, AUTOMOUNT_FAILURE_RESOURCES);
 }
 
-static void automount_enter_runnning(Automount *a) {
+static void automount_enter_running(Automount *a) {
         _cleanup_dbus_error_free_ DBusError error;
         struct stat st;
         int r;
@@ -609,18 +609,22 @@ static void automount_enter_runnning(Aut
                 goto fail;
         }
 
-        if (!S_ISDIR(st.st_mode) || st.st_dev != a->dev_id)
+        /* The mount unit may have been explicitly started before we got the
+         * autofs request. Ack it to unblock anything waiting on the mount point. */
+        if (!S_ISDIR(st.st_mode) || st.st_dev != a->dev_id) {
                 log_info_unit(UNIT(a)->id,
                               "%s's automount point already active?", UNIT(a)->id);
-        else {
-                r = manager_add_job(UNIT(a)->manager, JOB_START, UNIT_TRIGGER(UNIT(a)),
-                                    JOB_REPLACE, true, &error, NULL);
-                if (r < 0) {
-                        log_warning_unit(UNIT(a)->id,
-                                         "%s failed to queue mount startup job: %s",
-                                         UNIT(a)->id, bus_error(&error, r));
-                        goto fail;
-                }
+                automount_send_ready(a, 0);
+                return;
+        }
+
+        r = manager_add_job(UNIT(a)->manager, JOB_START, UNIT_TRIGGER(UNIT(a)),
+                            JOB_REPLACE, true, &error, NULL);
+        if (r < 0) {
+                log_warning_unit(UNIT(a)->id,
+                                 "%s failed to queue mount startup job: %s",
+                                 UNIT(a)->id, bus_error(&error, r));
+                goto fail;
         }
 
         automount_set_state(a, AUTOMOUNT_RUNNING);
@@ -819,7 +823,7 @@ static void automount_fd_event(Unit *u,
                         goto fail;
                 }
 
-                automount_enter_runnning(a);
+                automount_enter_running(a);
                 break;
 
         default:
