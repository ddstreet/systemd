From f0831ed2a03fcef582660be1c3b1a9f3e267e656 Mon Sep 17 00:00:00 2001
From: Lennart Poettering <lennart@poettering.net>
Date: Tue, 5 Jun 2018 16:53:22 +0200
Subject: [PATCH] core: add a new unit method "catchup()"
Bug-Ubuntu: https://bugs.launchpad.net/ubuntu/+source/systemd/+bug/1934147
Origin: upstream, https://github.com/systemd/systemd/commit/f0831ed2a03fcef582660be1c3b1a9f3e267e656

This is very similar to the existing unit method coldplug() but is
called a bit later. The idea is that that coldplug() restores the unit
state from before any prior reload/restart, i.e. puts the deserialized
state in effect. The catchup() call is then called a bit later, to
catch up with the system state for which we missed notifications while
we were reloading. This is only really useful for mount, swap and device
mount points were we should be careful to generate all missing unit
state change events (i.e. call unit_notify() appropriately) for
everything that happened while we were reloading.
---
 src/core/manager.c | 30 +++++++++++++++++++++++++++++-
 src/core/unit.c    | 11 ++++++++---
 src/core/unit.h    | 17 ++++++++++-------
 3 files changed, 47 insertions(+), 11 deletions(-)

--- a/src/core/manager.c
+++ b/src/core/manager.c
@@ -1290,7 +1290,9 @@ static void manager_coldplug(Manager *m)
 
         assert(m);
 
-        /* Then, let's set up their initial state. */
+        log_debug("Invoking unit coldplug() handlers…");
+
+        /* Let's place the units back into their deserialized state */
         HASHMAP_FOREACH_KEY(u, k, m->units, i) {
 
                 /* ignore aliases */
@@ -1303,6 +1305,26 @@ static void manager_coldplug(Manager *m)
         }
 }
 
+static void manager_catchup(Manager *m) {
+        Iterator i;
+        Unit *u;
+        char *k;
+
+        assert(m);
+
+        log_debug("Invoking unit catchup() handlers…");
+
+        /* Let's catch up on any state changes that happened while we were reloading/reexecing */
+        HASHMAP_FOREACH_KEY(u, k, m->units, i) {
+
+                /* ignore aliases */
+                if (u->id != k)
+                        continue;
+
+                unit_catchup(u);
+        }
+}
+
 static void manager_build_unit_path_cache(Manager *m) {
         char **i;
         int r;
@@ -1477,6 +1499,9 @@ int manager_startup(Manager *m, FILE *se
                 m->send_reloading_done = true;
         }
 
+        /* Let's finally catch up with any changes that took place while we were reloading/reexecing */
+        manager_catchup(m);
+
         return 0;
 }
 
@@ -3139,6 +3164,9 @@ int manager_reload(Manager *m) {
         /* It might be safe to log to the journal now. */
         manager_recheck_journal(m);
 
+        /* Let's finally catch up with any changes that took place while we were reloading/reexecing */
+        manager_catchup(m);
+
         /* Sync current state of bus names with our set of listening units */
         if (m->api_bus)
                 manager_sync_bus_names(m, m->api_bus);
--- a/src/core/unit.c
+++ b/src/core/unit.c
@@ -2331,7 +2331,6 @@ static void unit_update_on_console(Unit
                 manager_ref_console(u->manager);
         else
                 manager_unref_console(u->manager);
-
 }
 
 static bool unit_process_job(Job *j, UnitActiveState ns, UnitNotifyFlags flags) {
@@ -3788,8 +3787,7 @@ int unit_coldplug(Unit *u) {
 
         assert(u);
 
-        /* Make sure we don't enter a loop, when coldplugging
-         * recursively. */
+        /* Make sure we don't enter a loop, when coldplugging recursively. */
         if (u->coldplugged)
                 return 0;
 
@@ -3817,6 +3815,13 @@ int unit_coldplug(Unit *u) {
         return r;
 }
 
+void unit_catchup(Unit *u) {
+        assert(u);
+
+        if (UNIT_VTABLE(u)->catchup)
+                UNIT_VTABLE(u)->catchup(u);
+}
+
 static bool fragment_mtime_newer(const char *path, usec_t mtime, bool path_masked) {
         struct stat st;
 
--- a/src/core/unit.h
+++ b/src/core/unit.h
@@ -454,10 +454,14 @@ struct UnitVTable {
          * UNIT_STUB if no configuration could be found. */
         int (*load)(Unit *u);
 
-        /* If a lot of units got created via enumerate(), this is
-         * where to actually set the state and call unit_notify(). */
+        /* During deserialization we only record the intended state to return to. With coldplug() we actually put the
+         * deserialized state in effect. This is where unit_notify() should be called to start things up. */
         int (*coldplug)(Unit *u);
 
+        /* This is called shortly after all units' coldplug() call was invoked. It's supposed to catch up state changes
+         * we missed so far (for example because they took place while we were reloading/reexecing) */
+        void (*catchup)(Unit *u);
+
         void (*dump)(Unit *u, FILE *f, const char *prefix);
 
         int (*start)(Unit *u);
@@ -546,11 +550,9 @@ struct UnitVTable {
         /* Returns true if the unit currently needs access to the console */
         bool (*needs_console)(Unit *u);
 
-        /* This is called for each unit type and should be used to
-         * enumerate existing devices and load them. However,
-         * everything that is loaded here should still stay in
-         * inactive state. It is the job of the coldplug() call above
-         * to put the units into the initial state.  */
+        /* This is called for each unit type and should be used to enumerate units already existing in the system
+         * internally and load them. However, everything that is loaded here should still stay in inactive state. It is
+         * the job of the coldplug() call above to put the units into the initial state.  */
         void (*enumerate)(Manager *m);
 
         /* Type specific cleanups. */
@@ -705,6 +707,7 @@ void unit_serialize_item_format(Unit *u,
 int unit_add_node_dependency(Unit *u, const char *what, bool wants, UnitDependency d, UnitDependencyMask mask);
 
 int unit_coldplug(Unit *u);
+void unit_catchup(Unit *u);
 
 void unit_status_printf(Unit *u, const char *status, const char *unit_status_msg_format) _printf_(3, 0);
 void unit_status_emit_starting_stopping_reloading(Unit *u, JobType t);
