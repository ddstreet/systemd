Description: Do not exit when a DM_COOKIE event is pending.
Author: Herton R. Krzesinski
Ubuntu-Bug: https://bugs.launchpad.net/ubuntu/+source/lvm2/+bug/802626

Index: systemd/src/libudev/libudev-device.c
===================================================================
--- systemd.orig/src/libudev/libudev-device.c	2013-05-10 17:54:18.260318658 +0200
+++ systemd/src/libudev/libudev-device.c	2013-05-10 17:54:18.252318658 +0200
@@ -97,6 +97,7 @@
         bool is_initialized;
         bool sysattr_list_read;
         bool db_persist;
+        bool dm_cookie_set;
 };
 
 /**
@@ -359,6 +360,27 @@
         return 0;
 }
 
+/**
+ * udev_device_get_dm_cookie_set:
+ * @udev_device: udev device
+ *
+ * Retrieve the status of DM_COOKIE available for this udev device.
+ *
+ * Returns: true if DM_COOKIE was set for this device, false otherwise
+ **/
+bool udev_device_get_dm_cookie_set(struct udev_device *udev_device)
+{
+       if (udev_device == NULL)
+               return NULL;
+       return udev_device->dm_cookie_set;
+}
+
+static int udev_device_set_dm_cookie_set(struct udev_device *udev_device)
+{
+       udev_device->dm_cookie_set = true;
+       return 0;
+}
+
 struct udev_list_entry *udev_device_add_property(struct udev_device *udev_device, const char *key, const char *value)
 {
         udev_device->envp_uptodate = false;
@@ -470,6 +492,9 @@
                 udev_device_set_devnode_uid(udev_device, strtoul(&property[7], NULL, 10));
         } else if (startswith(property, "DEVGID=")) {
                 udev_device_set_devnode_gid(udev_device, strtoul(&property[7], NULL, 10));
+        } else if (startswith(property, "DM_COOKIE=")) {
+                udev_device_set_dm_cookie_set(udev_device);
+                udev_device_add_property_from_string(udev_device, property);
         } else {
                 udev_device_add_property_from_string(udev_device, property);
         }
Index: systemd/src/libudev/libudev-private.h
===================================================================
--- systemd.orig/src/libudev/libudev-private.h	2013-05-10 17:54:18.260318658 +0200
+++ systemd/src/libudev/libudev-private.h	2013-05-10 17:54:18.252318658 +0200
@@ -87,6 +87,7 @@
 void udev_device_set_info_loaded(struct udev_device *device);
 bool udev_device_get_db_persist(struct udev_device *udev_device);
 void udev_device_set_db_persist(struct udev_device *udev_device);
+bool udev_device_get_dm_cookie_set(struct udev_device *udev_device);
 
 /* libudev-device-private.c */
 int udev_device_update_db(struct udev_device *udev_device);
Index: systemd/src/udev/udevd.c
===================================================================
--- systemd.orig/src/udev/udevd.c	2013-05-10 17:54:18.260318658 +0200
+++ systemd/src/udev/udevd.c	2013-05-10 17:54:43.872318835 +0200
@@ -108,7 +108,17 @@
         return container_of(node, struct event, node);
 }
 
-static void event_queue_cleanup(struct udev *udev, enum event_state type);
+static void __event_queue_cleanup(struct udev *udev, enum event_state type, bool must_keep);
+
+static void event_queue_cleanup(struct udev *udev, enum event_state match_type)
+{
+       __event_queue_cleanup(udev, match_type, false);
+}
+
+static void event_queue_cleanup_onexit(struct udev *udev, enum event_state match_type)
+{
+       __event_queue_cleanup(udev, match_type, true);
+}
 
 enum worker_state {
         WORKER_UNDEF,
@@ -555,6 +565,7 @@
 static void event_queue_start(struct udev *udev)
 {
         struct udev_list_node *loop;
+        bool force;
 
         udev_list_node_foreach(loop, &event_list) {
                 struct event *event = node_to_event(loop);
@@ -562,6 +573,12 @@
                 if (event->state != EVENT_QUEUED)
                         continue;
 
+                /* do not schedule any more events if we are exiting,
+                   but we must process any remaining DM_COOKIE events */
+                force = udev_device_get_dm_cookie_set(event->dev);
+                if (udev_exit && !force)
+                        continue;
+
                 /* do not start event if parent or child event is still running */
                 if (is_devpath_busy(event))
                         continue;
@@ -570,7 +587,7 @@
         }
 }
 
-static void event_queue_cleanup(struct udev *udev, enum event_state match_type)
+static void __event_queue_cleanup(struct udev *udev, enum event_state match_type, bool must_keep)
 {
         struct udev_list_node *loop, *tmp;
 
@@ -580,6 +597,11 @@
                 if (match_type != EVENT_UNDEF && match_type != event->state)
                         continue;
 
+                /* Events with DM_COOKIE set must be kept and processed to
+                 * avoid potential lvm tools deadlock on udev_exit */
+                if (must_keep && udev_device_get_dm_cookie_set(event->dev))
+                        continue;
+
                 event_queue_delete(event, false);
         }
 }
@@ -1300,7 +1322,7 @@
                         }
 
                         /* discard queued events and kill workers */
-                        event_queue_cleanup(udev, EVENT_QUEUED);
+                        event_queue_cleanup_onexit(udev, EVENT_QUEUED);
                         worker_kill(udev);
 
                         /* exit after all has cleaned up */
@@ -1406,14 +1428,19 @@
 
                         dev = udev_monitor_receive_device(monitor);
                         if (dev != NULL) {
-                                udev_device_set_usec_initialized(dev, now(CLOCK_MONOTONIC));
-                                if (event_queue_insert(dev) < 0)
+                                /* If we are exiting then only schedule critical
+                                 * events (with DM_COOKIE set). */
+                                if (!udev_exit || udev_device_get_dm_cookie_set(dev)) {
+                                        udev_device_set_usec_initialized(dev, now(CLOCK_MONOTONIC));
+                                        if (event_queue_insert(dev) < 0)
+                                                udev_device_unref(dev);
+                                } else
                                         udev_device_unref(dev);
                         }
                 }
 
                 /* start new events */
-                if (!udev_list_node_is_empty(&event_list) && !udev_exit && !stop_exec_queue) {
+                if (!udev_list_node_is_empty(&event_list) && !stop_exec_queue) {
                         udev_builtin_init(udev);
                         if (rules == NULL)
                                 rules = udev_rules_new(udev, resolve_names);
