From: Dimitri John Ledkov <xnox@ubuntu.com>
Date: Tue, 26 Sep 2017 10:23:09 -0400
Subject: core: unlink the invocation id key, if cannot change keyring owner

KEYCTL_CHOWN fails under unpriviledged usernamespace containers that drop
CAP_SYS_ADMIN (eg. LXD, OpenVZ, etc). Because kernel checks the capability in
the initial namespace, rather than in the user namespace. Thus if KEYCTL_CHOWN
operation is required, but will be impossible to perform, unlink the key and
thus skip the keyring setup.

Fixes #6281

(cherry picked from commit e4945f3a577ac9233c0e71349b6c139899e742fc)
---
 src/basic/missing.h |  8 ++++++++
 src/core/execute.c  | 14 ++++++++++----
 2 files changed, 18 insertions(+), 4 deletions(-)

diff --git a/src/basic/missing.h b/src/basic/missing.h
index 352d2b0..8e1d45e 100644
--- a/src/basic/missing.h
+++ b/src/basic/missing.h
@@ -1132,6 +1132,14 @@ typedef int32_t key_serial_t;
 #define KEYCTL_LINK 8
 #endif
 
+#ifndef KEYCTL_LINK
+#define KEYCTL_LINK 8
+#endif
+
+#ifndef KEYCTL_UNLINK
+#define KEYCTL_UNLINK 9
+#endif
+
 #ifndef KEYCTL_READ
 #define KEYCTL_READ 11
 #endif
diff --git a/src/core/execute.c b/src/core/execute.c
index 749ed32..e1b31b9 100644
--- a/src/core/execute.c
+++ b/src/core/execute.c
@@ -2399,12 +2399,15 @@ static int setup_keyring(
                 uid_t uid, gid_t gid) {
 
         key_serial_t keyring;
+        key_serial_t key;
         int r;
 
         assert(u);
         assert(context);
         assert(p);
 
+        key = -1;
+
         /* Let's set up a new per-service "session" kernel keyring for each system service. This has the benefit that
          * each service runs with its own keyring shared among all processes of the service, but with no hook-up beyond
          * that scope, and in particular no link to the per-UID keyring. If we don't do this the keyring will be
@@ -2434,8 +2437,6 @@ static int setup_keyring(
 
         /* Populate they keyring with the invocation ID by default. */
         if (!sd_id128_is_null(u->invocation_id)) {
-                key_serial_t key;
-
                 key = add_key("user", "invocation_id", &u->invocation_id, sizeof(u->invocation_id), KEY_SPEC_SESSION_KEYRING);
                 if (key == -1)
                         log_unit_debug_errno(u, errno, "Failed to add invocation ID to keyring, ignoring: %m");
@@ -2449,8 +2450,13 @@ static int setup_keyring(
 
         /* And now, make the keyring owned by the service's user */
         if (uid_is_valid(uid) || gid_is_valid(gid))
-                if (keyctl(KEYCTL_CHOWN, keyring, uid, gid, 0) < 0)
-                        return log_unit_error_errno(u, errno, "Failed to change ownership of session keyring: %m");
+                if (keyctl(KEYCTL_CHOWN, keyring, uid, gid, 0) < 0) {
+                        log_unit_error_errno(u, errno, "Failed to change ownership of session keyring: %m");
+                        /* well, the kernel didn't - cause the kernel is borked */
+                        if (keyctl(KEYCTL_UNLINK, key, keyring, 0, 0) < 0)
+                                log_unit_debug_errno(u, errno, "Failed to unlink (clean-up) key, after failing to change ownership: %m");
+                        return 0;
+                }
 
         /* When requested link the user keyring into the session keyring. */
         if (context->keyring_mode == EXEC_KEYRING_SHARED) {
