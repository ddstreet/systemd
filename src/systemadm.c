/* systemadm.c generated by valac 0.11.6, the Vala compiler
 * generated from systemadm.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <pango/pango.h>
#include <gio/gio.h>
#include <time.h>


#define TYPE_LEFT_LABEL (left_label_get_type ())
#define LEFT_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LEFT_LABEL, LeftLabel))
#define LEFT_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LEFT_LABEL, LeftLabelClass))
#define IS_LEFT_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LEFT_LABEL))
#define IS_LEFT_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LEFT_LABEL))
#define LEFT_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LEFT_LABEL, LeftLabelClass))

typedef struct _LeftLabel LeftLabel;
typedef struct _LeftLabelClass LeftLabelClass;
typedef struct _LeftLabelPrivate LeftLabelPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_RIGHT_LABEL (right_label_get_type ())
#define RIGHT_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_RIGHT_LABEL, RightLabel))
#define RIGHT_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_RIGHT_LABEL, RightLabelClass))
#define IS_RIGHT_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_RIGHT_LABEL))
#define IS_RIGHT_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_RIGHT_LABEL))
#define RIGHT_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_RIGHT_LABEL, RightLabelClass))

typedef struct _RightLabel RightLabel;
typedef struct _RightLabelClass RightLabelClass;
typedef struct _RightLabelPrivate RightLabelPrivate;

#define TYPE_MAIN_WINDOW (main_window_get_type ())
#define MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAIN_WINDOW, MainWindow))
#define MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAIN_WINDOW, MainWindowClass))
#define IS_MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAIN_WINDOW))
#define IS_MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAIN_WINDOW))
#define MAIN_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAIN_WINDOW, MainWindowClass))

typedef struct _MainWindow MainWindow;
typedef struct _MainWindowClass MainWindowClass;
typedef struct _MainWindowPrivate MainWindowPrivate;

#define TYPE_MANAGER (manager_get_type ())
#define MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MANAGER, Manager))
#define IS_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MANAGER))
#define MANAGER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_MANAGER, ManagerIface))

typedef struct _Manager Manager;
typedef struct _ManagerIface ManagerIface;

#define TYPE_MANAGER_PROXY (manager_proxy_get_type ())

#define MANAGER_TYPE_UNIT_INFO (manager_unit_info_get_type ())
typedef struct _ManagerUnitInfo ManagerUnitInfo;

#define MANAGER_TYPE_JOB_INFO (manager_job_info_get_type ())
typedef struct _ManagerJobInfo ManagerJobInfo;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_UNIT (unit_get_type ())
#define UNIT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_UNIT, Unit))
#define IS_UNIT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_UNIT))
#define UNIT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_UNIT, UnitIface))

typedef struct _Unit Unit;
typedef struct _UnitIface UnitIface;

#define TYPE_UNIT_PROXY (unit_proxy_get_type ())

#define UNIT_TYPE_JOB_LINK (unit_job_link_get_type ())
typedef struct _UnitJobLink UnitJobLink;

#define TYPE_JOB (job_get_type ())
#define JOB(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_JOB, Job))
#define IS_JOB(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_JOB))
#define JOB_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_JOB, JobIface))

typedef struct _Job Job;
typedef struct _JobIface JobIface;

#define TYPE_JOB_PROXY (job_proxy_get_type ())

#define JOB_TYPE_UNIT_LINK (job_unit_link_get_type ())
typedef struct _JobUnitLink JobUnitLink;

#define TYPE_PROPERTIES (properties_get_type ())
#define PROPERTIES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROPERTIES, Properties))
#define IS_PROPERTIES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROPERTIES))
#define PROPERTIES_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_PROPERTIES, PropertiesIface))

typedef struct _Properties Properties;
typedef struct _PropertiesIface PropertiesIface;

#define TYPE_PROPERTIES_PROXY (properties_proxy_get_type ())
#define _gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _LeftLabel {
	GtkLabel parent_instance;
	LeftLabelPrivate * priv;
};

struct _LeftLabelClass {
	GtkLabelClass parent_class;
};

struct _RightLabel {
	GtkLabel parent_instance;
	RightLabelPrivate * priv;
};

struct _RightLabelClass {
	GtkLabelClass parent_class;
};

struct _MainWindow {
	GtkWindow parent_instance;
	MainWindowPrivate * priv;
};

struct _MainWindowClass {
	GtkWindowClass parent_class;
};

struct _ManagerUnitInfo {
	gchar* id;
	gchar* description;
	gchar* load_state;
	gchar* active_state;
	gchar* sub_state;
	gchar* following;
	char* unit_path;
	guint32 job_id;
	gchar* job_type;
	char* job_path;
};

struct _ManagerJobInfo {
	guint32 id;
	gchar* name;
	gchar* type;
	gchar* state;
	char* job_path;
	char* unit_path;
};

struct _ManagerIface {
	GTypeInterface parent_iface;
	ManagerUnitInfo* (*list_units) (Manager* self, int* result_length1, GError** error);
	ManagerJobInfo* (*list_jobs) (Manager* self, int* result_length1, GError** error);
	char* (*get_unit) (Manager* self, const gchar* name, GError** error);
	char* (*get_unit_by_pid) (Manager* self, guint32 pid, GError** error);
	char* (*load_unit) (Manager* self, const gchar* name, GError** error);
	char* (*get_job) (Manager* self, guint32 id, GError** error);
	char* (*start_unit) (Manager* self, const gchar* name, const gchar* mode, GError** error);
	char* (*stop_unit) (Manager* self, const gchar* name, const gchar* mode, GError** error);
	char* (*reload_unit) (Manager* self, const gchar* name, const gchar* mode, GError** error);
	char* (*restart_unit) (Manager* self, const gchar* name, const gchar* mode, GError** error);
	char* (*try_restart_unit) (Manager* self, const gchar* name, const gchar* mode, GError** error);
	char* (*reload_or_restart_unit) (Manager* self, const gchar* name, const gchar* mode, GError** error);
	char* (*reload_or_try_restart_unit) (Manager* self, const gchar* name, const gchar* mode, GError** error);
	void (*reset_failed_unit) (Manager* self, const gchar* name, GError** error);
	void (*clear_jobs) (Manager* self, GError** error);
	void (*subscribe) (Manager* self, GError** error);
	void (*unsubscribe) (Manager* self, GError** error);
	gchar* (*dump) (Manager* self, GError** error);
	void (*reload) (Manager* self, GError** error);
	void (*reexecute) (Manager* self, GError** error);
	void (*exit) (Manager* self, GError** error);
	void (*halt) (Manager* self, GError** error);
	void (*power_off) (Manager* self, GError** error);
	void (*reboot) (Manager* self, GError** error);
	void (*kexec) (Manager* self, GError** error);
	char* (*create_snapshot) (Manager* self, const gchar* name, gboolean cleanup, GError** error);
	void (*set_environment) (Manager* self, gchar** names, int names_length1, GError** error);
	void (*unset_environment) (Manager* self, gchar** names, int names_length1, GError** error);
	gchar** (*get_environment) (Manager* self, int* result_length1);
};

struct _MainWindowPrivate {
	gchar* current_unit_id;
	guint32 current_job_id;
	GtkTreeView* unit_view;
	GtkTreeView* job_view;
	GtkListStore* unit_model;
	GtkListStore* job_model;
	GtkButton* start_button;
	GtkButton* stop_button;
	GtkButton* restart_button;
	GtkButton* reload_button;
	GtkButton* cancel_button;
	GtkEntry* unit_load_entry;
	GtkButton* unit_load_button;
	GtkButton* server_snapshot_button;
	GtkButton* server_reload_button;
	Manager* manager;
	RightLabel* unit_id_label;
	RightLabel* unit_aliases_label;
	RightLabel* unit_dependency_label;
	RightLabel* unit_description_label;
	RightLabel* unit_load_state_label;
	RightLabel* unit_active_state_label;
	RightLabel* unit_sub_state_label;
	RightLabel* unit_fragment_path_label;
	RightLabel* unit_active_enter_timestamp_label;
	RightLabel* unit_active_exit_timestamp_label;
	RightLabel* unit_can_start_label;
	RightLabel* unit_can_reload_label;
	RightLabel* unit_cgroup_label;
	RightLabel* job_id_label;
	RightLabel* job_state_label;
	RightLabel* job_type_label;
	GtkComboBox* unit_type_combo_box;
};

struct _UnitJobLink {
	guint32 id;
	char* path;
};

struct _UnitIface {
	GTypeInterface parent_iface;
	char* (*start) (Unit* self, const gchar* mode, GError** error);
	char* (*stop) (Unit* self, const gchar* mode, GError** error);
	char* (*reload) (Unit* self, const gchar* mode, GError** error);
	char* (*restart) (Unit* self, const gchar* mode, GError** error);
	char* (*try_restart) (Unit* self, const gchar* mode, GError** error);
	char* (*reload_or_restart) (Unit* self, const gchar* mode, GError** error);
	char* (*reload_or_try_restart) (Unit* self, const gchar* mode, GError** error);
	void (*reset_failed) (Unit* self, GError** error);
	gchar* (*get_id) (Unit* self);
	gchar** (*get_names) (Unit* self, int* result_length1);
	gchar* (*get_following) (Unit* self);
	gchar** (*get_requires) (Unit* self, int* result_length1);
	gchar** (*get_requires_overridable) (Unit* self, int* result_length1);
	gchar** (*get_requisite) (Unit* self, int* result_length1);
	gchar** (*get_requisite_overridable) (Unit* self, int* result_length1);
	gchar** (*get_wants) (Unit* self, int* result_length1);
	gchar** (*get_required_by) (Unit* self, int* result_length1);
	gchar** (*get_required_by_overridable) (Unit* self, int* result_length1);
	gchar** (*get_wanted_by) (Unit* self, int* result_length1);
	gchar** (*get_conflicts) (Unit* self, int* result_length1);
	gchar** (*get_conflicted_by) (Unit* self, int* result_length1);
	gchar** (*get_before) (Unit* self, int* result_length1);
	gchar** (*get_after) (Unit* self, int* result_length1);
	gchar** (*get_on_failure) (Unit* self, int* result_length1);
	gchar* (*get_description) (Unit* self);
	gchar* (*get_load_state) (Unit* self);
	gchar* (*get_active_state) (Unit* self);
	gchar* (*get_sub_state) (Unit* self);
	gchar* (*get_fragment_path) (Unit* self);
	guint64 (*get_inactive_exit_timestamp) (Unit* self);
	guint64 (*get_active_enter_timestamp) (Unit* self);
	guint64 (*get_active_exit_timestamp) (Unit* self);
	guint64 (*get_inactive_enter_timestamp) (Unit* self);
	gboolean (*get_can_start) (Unit* self);
	gboolean (*get_can_stop) (Unit* self);
	gboolean (*get_can_reload) (Unit* self);
	void (*get_job) (Unit* self, UnitJobLink* value);
	gboolean (*get_recursive_stop) (Unit* self);
	gboolean (*get_stop_when_unneeded) (Unit* self);
	gboolean (*get_refuse_manual_start) (Unit* self);
	gboolean (*get_refuse_manual_stop) (Unit* self);
	gboolean (*get_default_dependencies) (Unit* self);
	gchar* (*get_default_control_group) (Unit* self);
	gchar** (*get_control_groups) (Unit* self, int* result_length1);
	gboolean (*get_need_daemon_reload) (Unit* self);
	guint64 (*get_job_timeout_usec) (Unit* self);
};

struct _JobUnitLink {
	gchar* id;
	char* path;
};

struct _JobIface {
	GTypeInterface parent_iface;
	void (*cancel) (Job* self, GError** error);
	guint32 (*get_id) (Job* self);
	gchar* (*get_state) (Job* self);
	gchar* (*get_job_type) (Job* self);
	void (*get_unit) (Job* self, JobUnitLink* value);
};

struct _PropertiesIface {
	GTypeInterface parent_iface;
	GVariant* (*get) (Properties* self, const gchar* iface, const gchar* property, GError** error);
};


extern gboolean user;
gboolean user = FALSE;
static gpointer left_label_parent_class = NULL;
static gpointer right_label_parent_class = NULL;
static gpointer main_window_parent_class = NULL;

GType left_label_get_type (void) G_GNUC_CONST;
enum  {
	LEFT_LABEL_DUMMY_PROPERTY
};
LeftLabel* left_label_new (const gchar* text);
LeftLabel* left_label_construct (GType object_type, const gchar* text);
GType right_label_get_type (void) G_GNUC_CONST;
enum  {
	RIGHT_LABEL_DUMMY_PROPERTY
};
RightLabel* right_label_new (const gchar* text);
RightLabel* right_label_construct (GType object_type, const gchar* text);
void right_label_set_text_or_na (RightLabel* self, const gchar* text);
void right_label_set_markup_or_na (RightLabel* self, const gchar* text);
GType main_window_get_type (void) G_GNUC_CONST;
GType manager_proxy_get_type (void) G_GNUC_CONST;
guint manager_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType manager_unit_info_get_type (void) G_GNUC_CONST;
ManagerUnitInfo* manager_unit_info_dup (const ManagerUnitInfo* self);
void manager_unit_info_free (ManagerUnitInfo* self);
void manager_unit_info_copy (const ManagerUnitInfo* self, ManagerUnitInfo* dest);
void manager_unit_info_destroy (ManagerUnitInfo* self);
GType manager_job_info_get_type (void) G_GNUC_CONST;
ManagerJobInfo* manager_job_info_dup (const ManagerJobInfo* self);
void manager_job_info_free (ManagerJobInfo* self);
void manager_job_info_copy (const ManagerJobInfo* self, ManagerJobInfo* dest);
void manager_job_info_destroy (ManagerJobInfo* self);
GType manager_get_type (void) G_GNUC_CONST;
#define MAIN_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MAIN_WINDOW, MainWindowPrivate))
enum  {
	MAIN_WINDOW_DUMMY_PROPERTY
};
MainWindow* main_window_new (GError** error);
MainWindow* main_window_construct (GType object_type, GError** error);
static void _gtk_main_quit_gtk_object_destroy (GtkObject* _sender, gpointer self);
void main_window_unit_type_changed (MainWindow* self);
static void _main_window_unit_type_changed_gtk_combo_box_changed (GtkComboBox* _sender, gpointer self);
void main_window_on_unit_load_entry_changed (MainWindow* self);
static void _main_window_on_unit_load_entry_changed_gtk_editable_changed (GtkEditable* _sender, gpointer self);
void main_window_on_unit_load (MainWindow* self);
static void _main_window_on_unit_load_gtk_entry_activate (GtkEntry* _sender, gpointer self);
static void _main_window_on_unit_load_gtk_button_clicked (GtkButton* _sender, gpointer self);
void main_window_on_server_snapshot (MainWindow* self);
static void _main_window_on_server_snapshot_gtk_button_clicked (GtkButton* _sender, gpointer self);
void main_window_on_server_reload (MainWindow* self);
static void _main_window_on_server_reload_gtk_button_clicked (GtkButton* _sender, gpointer self);
GType unit_proxy_get_type (void) G_GNUC_CONST;
guint unit_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType unit_job_link_get_type (void) G_GNUC_CONST;
UnitJobLink* unit_job_link_dup (const UnitJobLink* self);
void unit_job_link_free (UnitJobLink* self);
void unit_job_link_copy (const UnitJobLink* self, UnitJobLink* dest);
void unit_job_link_destroy (UnitJobLink* self);
GType unit_get_type (void) G_GNUC_CONST;
GType job_proxy_get_type (void) G_GNUC_CONST;
guint job_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType job_unit_link_get_type (void) G_GNUC_CONST;
JobUnitLink* job_unit_link_dup (const JobUnitLink* self);
void job_unit_link_free (JobUnitLink* self);
void job_unit_link_copy (const JobUnitLink* self, JobUnitLink* dest);
void job_unit_link_destroy (JobUnitLink* self);
GType job_get_type (void) G_GNUC_CONST;
gboolean main_window_unit_filter (MainWindow* self, GtkTreeModel* model, GtkTreeIter* iter);
static gboolean _main_window_unit_filter_gtk_tree_model_filter_visible_func (GtkTreeModel* model, GtkTreeIter* iter, gpointer self);
void main_window_unit_changed (MainWindow* self);
static void _main_window_unit_changed_gtk_tree_view_cursor_changed (GtkTreeView* _sender, gpointer self);
void main_window_job_changed (MainWindow* self);
static void _main_window_job_changed_gtk_tree_view_cursor_changed (GtkTreeView* _sender, gpointer self);
gboolean main_window_on_activate_link (MainWindow* self, const gchar* uri);
static gboolean _main_window_on_activate_link_gtk_label_activate_link (GtkLabel* _sender, const gchar* uri, gpointer self);
void main_window_on_start (MainWindow* self);
static void _main_window_on_start_gtk_button_clicked (GtkButton* _sender, gpointer self);
void main_window_on_stop (MainWindow* self);
static void _main_window_on_stop_gtk_button_clicked (GtkButton* _sender, gpointer self);
void main_window_on_reload (MainWindow* self);
static void _main_window_on_reload_gtk_button_clicked (GtkButton* _sender, gpointer self);
void main_window_on_restart (MainWindow* self);
static void _main_window_on_restart_gtk_button_clicked (GtkButton* _sender, gpointer self);
void main_window_on_cancel (MainWindow* self);
static void _main_window_on_cancel_gtk_button_clicked (GtkButton* _sender, gpointer self);
void main_window_on_unit_new (MainWindow* self, const gchar* id, const char* path);
static void _main_window_on_unit_new_manager_unit_new (Manager* _sender, const gchar* id, const char* path, gpointer self);
void main_window_on_job_new (MainWindow* self, guint32 id, const char* path);
static void _main_window_on_job_new_manager_job_new (Manager* _sender, guint32 id, const char* path, gpointer self);
void main_window_on_unit_removed (MainWindow* self, const gchar* id, const char* path);
static void _main_window_on_unit_removed_manager_unit_removed (Manager* _sender, const gchar* id, const char* path, gpointer self);
void main_window_on_job_removed (MainWindow* self, guint32 id, const char* path, const gchar* res);
static void _main_window_on_job_removed_manager_job_removed (Manager* _sender, guint32 id, const char* path, const gchar* res, gpointer self);
void manager_subscribe (Manager* self, GError** error);
void main_window_clear_unit (MainWindow* self);
void main_window_clear_job (MainWindow* self);
void main_window_populate_unit_model (MainWindow* self, GError** error);
void main_window_populate_job_model (MainWindow* self, GError** error);
ManagerUnitInfo* manager_list_units (Manager* self, int* result_length1, GError** error);
GType properties_proxy_get_type (void) G_GNUC_CONST;
guint properties_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType properties_get_type (void) G_GNUC_CONST;
static void _vala_ManagerUnitInfo_array_free (ManagerUnitInfo* array, gint array_length);
void main_window_on_unit_changed (MainWindow* self, Properties* p, const gchar* iface, GHashTable* changed_properties, gchar** invalidated_properties, int invalidated_properties_length1);
static void _main_window_on_unit_changed_properties_properties_changed (Properties* _sender, const gchar* iface, GHashTable* changed_properties, gchar** invalidated_properties, int invalidated_properties_length1, gpointer self);
ManagerJobInfo* manager_list_jobs (Manager* self, int* result_length1, GError** error);
static void _vala_ManagerJobInfo_array_free (ManagerJobInfo* array, gint array_length);
void main_window_on_job_changed (MainWindow* self, Properties* p, const gchar* iface, GHashTable* changed_properties, gchar** invalidated_properties, int invalidated_properties_length1);
static void _main_window_on_job_changed_properties_properties_changed (Properties* _sender, const gchar* iface, GHashTable* changed_properties, gchar** invalidated_properties, int invalidated_properties_length1, gpointer self);
Unit* main_window_get_current_unit (MainWindow* self);
void main_window_show_unit (MainWindow* self, Unit* unit);
gchar* main_window_make_dependency_string (MainWindow* self, const gchar* prefix, const gchar* word, gchar** dependencies, int dependencies_length1);
gchar* unit_get_id (Unit* self);
gchar** unit_get_names (Unit* self, int* result_length1);
gchar** unit_get_requires (Unit* self, int* result_length1);
gchar** unit_get_requires_overridable (Unit* self, int* result_length1);
gchar** unit_get_requisite (Unit* self, int* result_length1);
gchar** unit_get_requisite_overridable (Unit* self, int* result_length1);
gchar** unit_get_wants (Unit* self, int* result_length1);
gchar** unit_get_required_by (Unit* self, int* result_length1);
gchar** unit_get_required_by_overridable (Unit* self, int* result_length1);
gchar** unit_get_wanted_by (Unit* self, int* result_length1);
gchar** unit_get_conflicts (Unit* self, int* result_length1);
gchar** unit_get_before (Unit* self, int* result_length1);
gchar** unit_get_after (Unit* self, int* result_length1);
gchar* unit_get_description (Unit* self);
gchar* unit_get_load_state (Unit* self);
gchar* unit_get_active_state (Unit* self);
gchar* unit_get_sub_state (Unit* self);
gchar* unit_get_fragment_path (Unit* self);
guint64 unit_get_active_enter_timestamp (Unit* self);
guint64 unit_get_active_exit_timestamp (Unit* self);
gboolean unit_get_can_start (Unit* self);
gboolean unit_get_can_reload (Unit* self);
gchar* unit_get_default_control_group (Unit* self);
Job* main_window_get_current_job (MainWindow* self);
void main_window_show_job (MainWindow* self, Job* job);
guint32 job_get_id (Job* self);
gchar* job_get_state (Job* self);
gchar* job_get_job_type (Job* self);
char* unit_start (Unit* self, const gchar* mode, GError** error);
void main_window_show_error (MainWindow* self, const gchar* e);
char* unit_stop (Unit* self, const gchar* mode, GError** error);
char* unit_reload (Unit* self, const gchar* mode, GError** error);
char* unit_restart (Unit* self, const gchar* mode, GError** error);
void job_cancel (Job* self, GError** error);
void main_window_update_unit_iter (MainWindow* self, GtkTreeIter* iter, const gchar* id, Unit* u);
void unit_get_job (Unit* self, UnitJobLink* result);
void main_window_update_job_iter (MainWindow* self, GtkTreeIter* iter, guint32 id, Job* j);
void job_get_unit (Job* self, JobUnitLink* result);
void manager_reload (Manager* self, GError** error);
char* manager_create_snapshot (Manager* self, const gchar* name, gboolean cleanup, GError** error);
char* manager_load_unit (Manager* self, const gchar* name, GError** error);
char* manager_get_unit (Manager* self, const gchar* name, GError** error);
static void main_window_finalize (GObject* obj);
void show_error (const gchar* e);
gint _vala_main (gchar** args, int args_length1);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

const GOptionEntry entries[3] = {{"user", (gchar) 0, 0, G_OPTION_ARG_NONE, &user, "Connect to user service manager", NULL}, {"system", (gchar) 0, (gint) G_OPTION_FLAG_REVERSE, G_OPTION_ARG_NONE, &user, "Connect to system manager", NULL}, {NULL}};

LeftLabel* left_label_construct (GType object_type, const gchar* text) {
	LeftLabel * self = NULL;
	self = (LeftLabel*) g_object_new (object_type, NULL);
	if (text != NULL) {
		gchar* _tmp0_ = NULL;
		gchar* _tmp1_;
		_tmp0_ = g_strdup_printf ("<b>%s</b>", text);
		_tmp1_ = _tmp0_;
		gtk_label_set_markup ((GtkLabel*) self, _tmp1_);
		_g_free0 (_tmp1_);
	}
	gtk_misc_set_alignment ((GtkMisc*) self, (gfloat) 0, (gfloat) 0);
	gtk_misc_set_padding ((GtkMisc*) self, 6, 0);
	return self;
}


LeftLabel* left_label_new (const gchar* text) {
	return left_label_construct (TYPE_LEFT_LABEL, text);
}


static void left_label_class_init (LeftLabelClass * klass) {
	left_label_parent_class = g_type_class_peek_parent (klass);
}


static void left_label_instance_init (LeftLabel * self) {
}


GType left_label_get_type (void) {
	static volatile gsize left_label_type_id__volatile = 0;
	if (g_once_init_enter (&left_label_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (LeftLabelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) left_label_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (LeftLabel), 0, (GInstanceInitFunc) left_label_instance_init, NULL };
		GType left_label_type_id;
		left_label_type_id = g_type_register_static (GTK_TYPE_LABEL, "LeftLabel", &g_define_type_info, 0);
		g_once_init_leave (&left_label_type_id__volatile, left_label_type_id);
	}
	return left_label_type_id__volatile;
}


RightLabel* right_label_construct (GType object_type, const gchar* text) {
	RightLabel * self = NULL;
	self = (RightLabel*) g_object_new (object_type, NULL);
	right_label_set_text_or_na (self, text);
	gtk_misc_set_alignment ((GtkMisc*) self, (gfloat) 0, (gfloat) 0);
	gtk_label_set_ellipsize ((GtkLabel*) self, PANGO_ELLIPSIZE_START);
	gtk_label_set_selectable ((GtkLabel*) self, TRUE);
	return self;
}


RightLabel* right_label_new (const gchar* text) {
	return right_label_construct (TYPE_RIGHT_LABEL, text);
}


void right_label_set_text_or_na (RightLabel* self, const gchar* text) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	if (text == NULL) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = g_strcmp0 (text, "") == 0;
	}
	if (_tmp0_) {
		gtk_label_set_markup ((GtkLabel*) self, "<i>n/a</i>");
	} else {
		gtk_label_set_text ((GtkLabel*) self, text);
	}
}


void right_label_set_markup_or_na (RightLabel* self, const gchar* text) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	if (text == NULL) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = g_strcmp0 (text, "") == 0;
	}
	if (_tmp0_) {
		gtk_label_set_markup ((GtkLabel*) self, "<i>n/a</i>");
	} else {
		gtk_label_set_markup ((GtkLabel*) self, text);
	}
}


static void right_label_class_init (RightLabelClass * klass) {
	right_label_parent_class = g_type_class_peek_parent (klass);
}


static void right_label_instance_init (RightLabel * self) {
}


GType right_label_get_type (void) {
	static volatile gsize right_label_type_id__volatile = 0;
	if (g_once_init_enter (&right_label_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (RightLabelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) right_label_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RightLabel), 0, (GInstanceInitFunc) right_label_instance_init, NULL };
		GType right_label_type_id;
		right_label_type_id = g_type_register_static (GTK_TYPE_LABEL, "RightLabel", &g_define_type_info, 0);
		g_once_init_leave (&right_label_type_id__volatile, right_label_type_id);
	}
	return right_label_type_id__volatile;
}


static void _gtk_main_quit_gtk_object_destroy (GtkObject* _sender, gpointer self) {
	gtk_main_quit ();
}


static void _main_window_unit_type_changed_gtk_combo_box_changed (GtkComboBox* _sender, gpointer self) {
	main_window_unit_type_changed (self);
}


static void _main_window_on_unit_load_entry_changed_gtk_editable_changed (GtkEditable* _sender, gpointer self) {
	main_window_on_unit_load_entry_changed (self);
}


static void _main_window_on_unit_load_gtk_entry_activate (GtkEntry* _sender, gpointer self) {
	main_window_on_unit_load (self);
}


static void _main_window_on_unit_load_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	main_window_on_unit_load (self);
}


static void _main_window_on_server_snapshot_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	main_window_on_server_snapshot (self);
}


static void _main_window_on_server_reload_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	main_window_on_server_reload (self);
}


static gboolean _main_window_unit_filter_gtk_tree_model_filter_visible_func (GtkTreeModel* model, GtkTreeIter* iter, gpointer self) {
	gboolean result;
	result = main_window_unit_filter (self, model, iter);
	return result;
}


static void _main_window_unit_changed_gtk_tree_view_cursor_changed (GtkTreeView* _sender, gpointer self) {
	main_window_unit_changed (self);
}


static void _main_window_job_changed_gtk_tree_view_cursor_changed (GtkTreeView* _sender, gpointer self) {
	main_window_job_changed (self);
}


static gboolean _main_window_on_activate_link_gtk_label_activate_link (GtkLabel* _sender, const gchar* uri, gpointer self) {
	gboolean result;
	result = main_window_on_activate_link (self, uri);
	return result;
}


static void _main_window_on_start_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	main_window_on_start (self);
}


static void _main_window_on_stop_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	main_window_on_stop (self);
}


static void _main_window_on_reload_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	main_window_on_reload (self);
}


static void _main_window_on_restart_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	main_window_on_restart (self);
}


static void _main_window_on_cancel_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	main_window_on_cancel (self);
}


static void _main_window_on_unit_new_manager_unit_new (Manager* _sender, const gchar* id, const char* path, gpointer self) {
	main_window_on_unit_new (self, id, path);
}


static void _main_window_on_job_new_manager_job_new (Manager* _sender, guint32 id, const char* path, gpointer self) {
	main_window_on_job_new (self, id, path);
}


static void _main_window_on_unit_removed_manager_unit_removed (Manager* _sender, const gchar* id, const char* path, gpointer self) {
	main_window_on_unit_removed (self, id, path);
}


static void _main_window_on_job_removed_manager_job_removed (Manager* _sender, guint32 id, const char* path, const gchar* res, gpointer self) {
	main_window_on_job_removed (self, id, path, res);
}


MainWindow* main_window_construct (GType object_type, GError** error) {
	MainWindow * self = NULL;
	const gchar* _tmp0_ = NULL;
	GtkNotebook* _tmp1_ = NULL;
	GtkNotebook* notebook;
	GtkVBox* _tmp2_ = NULL;
	GtkBox* unit_vbox;
	GtkLabel* _tmp3_ = NULL;
	GtkLabel* _tmp4_;
	GtkVBox* _tmp5_ = NULL;
	GtkBox* job_vbox;
	GtkLabel* _tmp6_ = NULL;
	GtkLabel* _tmp7_;
	GtkComboBox* _tmp8_ = NULL;
	GtkComboBox* _tmp9_;
	GtkHBox* _tmp10_ = NULL;
	GtkBox* type_hbox;
	GtkEntry* _tmp11_ = NULL;
	GtkEntry* _tmp12_;
	GtkButton* _tmp13_ = NULL;
	GtkButton* _tmp14_;
	GtkHBox* _tmp15_ = NULL;
	GtkBox* unit_load_hbox;
	GtkButton* _tmp16_ = NULL;
	GtkButton* _tmp17_;
	GtkButton* _tmp18_ = NULL;
	GtkButton* _tmp19_;
	GtkListStore* _tmp20_ = NULL;
	GtkListStore* _tmp21_;
	GtkListStore* _tmp22_ = NULL;
	GtkListStore* _tmp23_;
	GtkTreeModelFilter* unit_model_filter = NULL;
	GtkTreeModelFilter* _tmp24_ = NULL;
	GtkTreeModelFilter* _tmp25_;
	GtkTreeView* _tmp26_ = NULL;
	GtkTreeView* _tmp27_;
	GtkTreeView* _tmp28_ = NULL;
	GtkTreeView* _tmp29_;
	GtkCellRendererText* _tmp30_ = NULL;
	GtkCellRendererText* _tmp31_;
	GtkCellRendererText* _tmp32_ = NULL;
	GtkCellRendererText* _tmp33_;
	GtkCellRendererText* _tmp34_ = NULL;
	GtkCellRendererText* _tmp35_;
	GtkCellRendererText* _tmp36_ = NULL;
	GtkCellRendererText* _tmp37_;
	GtkCellRendererText* _tmp38_ = NULL;
	GtkCellRendererText* _tmp39_;
	GtkCellRendererText* _tmp40_ = NULL;
	GtkCellRendererText* _tmp41_;
	GtkCellRendererText* _tmp42_ = NULL;
	GtkCellRendererText* _tmp43_;
	GtkCellRendererText* _tmp44_ = NULL;
	GtkCellRendererText* _tmp45_;
	GtkCellRendererText* _tmp46_ = NULL;
	GtkCellRendererText* _tmp47_;
	GtkScrolledWindow* _tmp48_ = NULL;
	GtkScrolledWindow* scroll;
	GtkScrolledWindow* _tmp49_ = NULL;
	GtkScrolledWindow* _tmp50_;
	RightLabel* _tmp51_ = NULL;
	RightLabel* _tmp52_;
	RightLabel* _tmp53_ = NULL;
	RightLabel* _tmp54_;
	RightLabel* _tmp55_ = NULL;
	RightLabel* _tmp56_;
	RightLabel* _tmp57_ = NULL;
	RightLabel* _tmp58_;
	RightLabel* _tmp59_ = NULL;
	RightLabel* _tmp60_;
	RightLabel* _tmp61_ = NULL;
	RightLabel* _tmp62_;
	RightLabel* _tmp63_ = NULL;
	RightLabel* _tmp64_;
	RightLabel* _tmp65_ = NULL;
	RightLabel* _tmp66_;
	RightLabel* _tmp67_ = NULL;
	RightLabel* _tmp68_;
	RightLabel* _tmp69_ = NULL;
	RightLabel* _tmp70_;
	RightLabel* _tmp71_ = NULL;
	RightLabel* _tmp72_;
	RightLabel* _tmp73_ = NULL;
	RightLabel* _tmp74_;
	RightLabel* _tmp75_ = NULL;
	RightLabel* _tmp76_;
	RightLabel* _tmp77_ = NULL;
	RightLabel* _tmp78_;
	RightLabel* _tmp79_ = NULL;
	RightLabel* _tmp80_;
	RightLabel* _tmp81_ = NULL;
	RightLabel* _tmp82_;
	GtkTable* _tmp83_ = NULL;
	GtkTable* unit_table;
	GtkTable* _tmp84_ = NULL;
	GtkTable* job_table;
	LeftLabel* _tmp85_ = NULL;
	LeftLabel* _tmp86_;
	LeftLabel* _tmp87_ = NULL;
	LeftLabel* _tmp88_;
	LeftLabel* _tmp89_ = NULL;
	LeftLabel* _tmp90_;
	LeftLabel* _tmp91_ = NULL;
	LeftLabel* _tmp92_;
	LeftLabel* _tmp93_ = NULL;
	LeftLabel* _tmp94_;
	LeftLabel* _tmp95_ = NULL;
	LeftLabel* _tmp96_;
	LeftLabel* _tmp97_ = NULL;
	LeftLabel* _tmp98_;
	LeftLabel* _tmp99_ = NULL;
	LeftLabel* _tmp100_;
	LeftLabel* _tmp101_ = NULL;
	LeftLabel* _tmp102_;
	LeftLabel* _tmp103_ = NULL;
	LeftLabel* _tmp104_;
	LeftLabel* _tmp105_ = NULL;
	LeftLabel* _tmp106_;
	LeftLabel* _tmp107_ = NULL;
	LeftLabel* _tmp108_;
	LeftLabel* _tmp109_ = NULL;
	LeftLabel* _tmp110_;
	LeftLabel* _tmp111_ = NULL;
	LeftLabel* _tmp112_;
	LeftLabel* _tmp113_ = NULL;
	LeftLabel* _tmp114_;
	LeftLabel* _tmp115_ = NULL;
	LeftLabel* _tmp116_;
	GtkHButtonBox* _tmp117_ = NULL;
	GtkButtonBox* bbox;
	GtkButton* _tmp118_ = NULL;
	GtkButton* _tmp119_;
	GtkButton* _tmp120_ = NULL;
	GtkButton* _tmp121_;
	GtkButton* _tmp122_ = NULL;
	GtkButton* _tmp123_;
	GtkButton* _tmp124_ = NULL;
	GtkButton* _tmp125_;
	GtkHButtonBox* _tmp126_ = NULL;
	GtkButtonBox* _tmp127_;
	GtkButton* _tmp128_ = NULL;
	GtkButton* _tmp129_;
	GBusType _tmp130_ = 0;
	Manager* _tmp131_ = NULL;
	Manager* _tmp132_;
	Manager* _tmp133_;
	GError * _inner_error_ = NULL;
	self = (MainWindow*) g_object_new (object_type, NULL);
	if (user) {
		_tmp0_ = "systemd User Service Manager";
	} else {
		_tmp0_ = "systemd System Manager";
	}
	gtk_window_set_title ((GtkWindow*) self, _tmp0_);
	gtk_window_set_position ((GtkWindow*) self, GTK_WIN_POS_CENTER);
	gtk_window_set_default_size ((GtkWindow*) self, 1000, 700);
	gtk_container_set_border_width ((GtkContainer*) self, (guint) 12);
	g_signal_connect ((GtkObject*) self, "destroy", (GCallback) _gtk_main_quit_gtk_object_destroy, NULL);
	_tmp1_ = (GtkNotebook*) gtk_notebook_new ();
	notebook = g_object_ref_sink (_tmp1_);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) notebook);
	_tmp2_ = (GtkVBox*) gtk_vbox_new (FALSE, 12);
	unit_vbox = (GtkBox*) g_object_ref_sink (_tmp2_);
	_tmp3_ = (GtkLabel*) gtk_label_new ("Units");
	_tmp4_ = g_object_ref_sink (_tmp3_);
	gtk_notebook_append_page (notebook, (GtkWidget*) unit_vbox, (GtkWidget*) _tmp4_);
	_g_object_unref0 (_tmp4_);
	gtk_container_set_border_width ((GtkContainer*) unit_vbox, (guint) 12);
	_tmp5_ = (GtkVBox*) gtk_vbox_new (FALSE, 12);
	job_vbox = (GtkBox*) g_object_ref_sink (_tmp5_);
	_tmp6_ = (GtkLabel*) gtk_label_new ("Jobs");
	_tmp7_ = g_object_ref_sink (_tmp6_);
	gtk_notebook_append_page (notebook, (GtkWidget*) job_vbox, (GtkWidget*) _tmp7_);
	_g_object_unref0 (_tmp7_);
	gtk_container_set_border_width ((GtkContainer*) job_vbox, (guint) 12);
	_tmp8_ = (GtkComboBox*) gtk_combo_box_new_text ();
	_tmp9_ = g_object_ref_sink (_tmp8_);
	_g_object_unref0 (self->priv->unit_type_combo_box);
	self->priv->unit_type_combo_box = _tmp9_;
	_tmp10_ = (GtkHBox*) gtk_hbox_new (FALSE, 6);
	type_hbox = (GtkBox*) g_object_ref_sink (_tmp10_);
	gtk_box_pack_start (type_hbox, (GtkWidget*) self->priv->unit_type_combo_box, FALSE, FALSE, (guint) 0);
	gtk_box_pack_start (unit_vbox, (GtkWidget*) type_hbox, FALSE, FALSE, (guint) 0);
	gtk_combo_box_append_text (self->priv->unit_type_combo_box, "Show All Units");
	gtk_combo_box_append_text (self->priv->unit_type_combo_box, "Show Only Live Units");
	gtk_combo_box_append_text (self->priv->unit_type_combo_box, "Services");
	gtk_combo_box_append_text (self->priv->unit_type_combo_box, "Sockets");
	gtk_combo_box_append_text (self->priv->unit_type_combo_box, "Devices");
	gtk_combo_box_append_text (self->priv->unit_type_combo_box, "Mounts");
	gtk_combo_box_append_text (self->priv->unit_type_combo_box, "Automounts");
	gtk_combo_box_append_text (self->priv->unit_type_combo_box, "Targets");
	gtk_combo_box_append_text (self->priv->unit_type_combo_box, "Snapshots");
	gtk_combo_box_set_active (self->priv->unit_type_combo_box, 1);
	g_signal_connect_object (self->priv->unit_type_combo_box, "changed", (GCallback) _main_window_unit_type_changed_gtk_combo_box_changed, self, 0);
	_tmp11_ = (GtkEntry*) gtk_entry_new ();
	_tmp12_ = g_object_ref_sink (_tmp11_);
	_g_object_unref0 (self->priv->unit_load_entry);
	self->priv->unit_load_entry = _tmp12_;
	_tmp13_ = (GtkButton*) gtk_button_new_with_mnemonic ("_Load");
	_tmp14_ = g_object_ref_sink (_tmp13_);
	_g_object_unref0 (self->priv->unit_load_button);
	self->priv->unit_load_button = _tmp14_;
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->unit_load_button, FALSE);
	g_signal_connect_object ((GtkEditable*) self->priv->unit_load_entry, "changed", (GCallback) _main_window_on_unit_load_entry_changed_gtk_editable_changed, self, 0);
	g_signal_connect_object (self->priv->unit_load_entry, "activate", (GCallback) _main_window_on_unit_load_gtk_entry_activate, self, 0);
	g_signal_connect_object (self->priv->unit_load_button, "clicked", (GCallback) _main_window_on_unit_load_gtk_button_clicked, self, 0);
	_tmp15_ = (GtkHBox*) gtk_hbox_new (FALSE, 6);
	unit_load_hbox = (GtkBox*) g_object_ref_sink (_tmp15_);
	gtk_box_pack_start (unit_load_hbox, (GtkWidget*) self->priv->unit_load_entry, FALSE, TRUE, (guint) 0);
	gtk_box_pack_start (unit_load_hbox, (GtkWidget*) self->priv->unit_load_button, FALSE, TRUE, (guint) 0);
	_tmp16_ = (GtkButton*) gtk_button_new_with_mnemonic ("Take S_napshot");
	_tmp17_ = g_object_ref_sink (_tmp16_);
	_g_object_unref0 (self->priv->server_snapshot_button);
	self->priv->server_snapshot_button = _tmp17_;
	_tmp18_ = (GtkButton*) gtk_button_new_with_mnemonic ("Reload _Configuration");
	_tmp19_ = g_object_ref_sink (_tmp18_);
	_g_object_unref0 (self->priv->server_reload_button);
	self->priv->server_reload_button = _tmp19_;
	g_signal_connect_object (self->priv->server_snapshot_button, "clicked", (GCallback) _main_window_on_server_snapshot_gtk_button_clicked, self, 0);
	g_signal_connect_object (self->priv->server_reload_button, "clicked", (GCallback) _main_window_on_server_reload_gtk_button_clicked, self, 0);
	gtk_box_pack_end (type_hbox, (GtkWidget*) self->priv->server_snapshot_button, FALSE, TRUE, (guint) 0);
	gtk_box_pack_end (type_hbox, (GtkWidget*) self->priv->server_reload_button, FALSE, TRUE, (guint) 0);
	gtk_box_pack_end (type_hbox, (GtkWidget*) unit_load_hbox, FALSE, TRUE, (guint) 24);
	_tmp20_ = gtk_list_store_new (7, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, TYPE_UNIT);
	_tmp21_ = _tmp20_;
	_g_object_unref0 (self->priv->unit_model);
	self->priv->unit_model = _tmp21_;
	_tmp22_ = gtk_list_store_new (6, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, TYPE_JOB, G_TYPE_UINT);
	_tmp23_ = _tmp22_;
	_g_object_unref0 (self->priv->job_model);
	self->priv->job_model = _tmp23_;
	_tmp24_ = (GtkTreeModelFilter*) gtk_tree_model_filter_new ((GtkTreeModel*) self->priv->unit_model, NULL);
	_tmp25_ = _tmp24_;
	_g_object_unref0 (unit_model_filter);
	unit_model_filter = _tmp25_;
	gtk_tree_model_filter_set_visible_func (unit_model_filter, _main_window_unit_filter_gtk_tree_model_filter_visible_func, g_object_ref (self), g_object_unref);
	_tmp26_ = (GtkTreeView*) gtk_tree_view_new_with_model ((GtkTreeModel*) unit_model_filter);
	_tmp27_ = g_object_ref_sink (_tmp26_);
	_g_object_unref0 (self->priv->unit_view);
	self->priv->unit_view = _tmp27_;
	_tmp28_ = (GtkTreeView*) gtk_tree_view_new_with_model ((GtkTreeModel*) self->priv->job_model);
	_tmp29_ = g_object_ref_sink (_tmp28_);
	_g_object_unref0 (self->priv->job_view);
	self->priv->job_view = _tmp29_;
	g_signal_connect_object (self->priv->unit_view, "cursor-changed", (GCallback) _main_window_unit_changed_gtk_tree_view_cursor_changed, self, 0);
	g_signal_connect_object (self->priv->job_view, "cursor-changed", (GCallback) _main_window_job_changed_gtk_tree_view_cursor_changed, self, 0);
	_tmp30_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	_tmp31_ = g_object_ref_sink (_tmp30_);
	gtk_tree_view_insert_column_with_attributes (self->priv->unit_view, -1, "Load State", (GtkCellRenderer*) _tmp31_, "text", 2, NULL);
	_g_object_unref0 (_tmp31_);
	_tmp32_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	_tmp33_ = g_object_ref_sink (_tmp32_);
	gtk_tree_view_insert_column_with_attributes (self->priv->unit_view, -1, "Active State", (GtkCellRenderer*) _tmp33_, "text", 3, NULL);
	_g_object_unref0 (_tmp33_);
	_tmp34_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	_tmp35_ = g_object_ref_sink (_tmp34_);
	gtk_tree_view_insert_column_with_attributes (self->priv->unit_view, -1, "Unit State", (GtkCellRenderer*) _tmp35_, "text", 4, NULL);
	_g_object_unref0 (_tmp35_);
	_tmp36_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	_tmp37_ = g_object_ref_sink (_tmp36_);
	gtk_tree_view_insert_column_with_attributes (self->priv->unit_view, -1, "Unit", (GtkCellRenderer*) _tmp37_, "text", 0, NULL);
	_g_object_unref0 (_tmp37_);
	_tmp38_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	_tmp39_ = g_object_ref_sink (_tmp38_);
	gtk_tree_view_insert_column_with_attributes (self->priv->unit_view, -1, "Job", (GtkCellRenderer*) _tmp39_, "text", 5, NULL);
	_g_object_unref0 (_tmp39_);
	_tmp40_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	_tmp41_ = g_object_ref_sink (_tmp40_);
	gtk_tree_view_insert_column_with_attributes (self->priv->job_view, -1, "Job", (GtkCellRenderer*) _tmp41_, "text", 0, NULL);
	_g_object_unref0 (_tmp41_);
	_tmp42_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	_tmp43_ = g_object_ref_sink (_tmp42_);
	gtk_tree_view_insert_column_with_attributes (self->priv->job_view, -1, "Unit", (GtkCellRenderer*) _tmp43_, "text", 1, NULL);
	_g_object_unref0 (_tmp43_);
	_tmp44_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	_tmp45_ = g_object_ref_sink (_tmp44_);
	gtk_tree_view_insert_column_with_attributes (self->priv->job_view, -1, "Type", (GtkCellRenderer*) _tmp45_, "text", 2, NULL);
	_g_object_unref0 (_tmp45_);
	_tmp46_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	_tmp47_ = g_object_ref_sink (_tmp46_);
	gtk_tree_view_insert_column_with_attributes (self->priv->job_view, -1, "State", (GtkCellRenderer*) _tmp47_, "text", 3, NULL);
	_g_object_unref0 (_tmp47_);
	_tmp48_ = (GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL);
	scroll = g_object_ref_sink (_tmp48_);
	gtk_scrolled_window_set_policy (scroll, GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type (scroll, GTK_SHADOW_IN);
	gtk_container_add ((GtkContainer*) scroll, (GtkWidget*) self->priv->unit_view);
	gtk_box_pack_start (unit_vbox, (GtkWidget*) scroll, TRUE, TRUE, (guint) 0);
	_tmp49_ = (GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL);
	_tmp50_ = g_object_ref_sink (_tmp49_);
	_g_object_unref0 (scroll);
	scroll = _tmp50_;
	gtk_scrolled_window_set_policy (scroll, GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type (scroll, GTK_SHADOW_IN);
	gtk_container_add ((GtkContainer*) scroll, (GtkWidget*) self->priv->job_view);
	gtk_box_pack_start (job_vbox, (GtkWidget*) scroll, TRUE, TRUE, (guint) 0);
	_tmp51_ = right_label_new (NULL);
	_tmp52_ = g_object_ref_sink (_tmp51_);
	_g_object_unref0 (self->priv->unit_id_label);
	self->priv->unit_id_label = _tmp52_;
	_tmp53_ = right_label_new (NULL);
	_tmp54_ = g_object_ref_sink (_tmp53_);
	_g_object_unref0 (self->priv->unit_aliases_label);
	self->priv->unit_aliases_label = _tmp54_;
	_tmp55_ = right_label_new (NULL);
	_tmp56_ = g_object_ref_sink (_tmp55_);
	_g_object_unref0 (self->priv->unit_dependency_label);
	self->priv->unit_dependency_label = _tmp56_;
	_tmp57_ = right_label_new (NULL);
	_tmp58_ = g_object_ref_sink (_tmp57_);
	_g_object_unref0 (self->priv->unit_description_label);
	self->priv->unit_description_label = _tmp58_;
	_tmp59_ = right_label_new (NULL);
	_tmp60_ = g_object_ref_sink (_tmp59_);
	_g_object_unref0 (self->priv->unit_load_state_label);
	self->priv->unit_load_state_label = _tmp60_;
	_tmp61_ = right_label_new (NULL);
	_tmp62_ = g_object_ref_sink (_tmp61_);
	_g_object_unref0 (self->priv->unit_active_state_label);
	self->priv->unit_active_state_label = _tmp62_;
	_tmp63_ = right_label_new (NULL);
	_tmp64_ = g_object_ref_sink (_tmp63_);
	_g_object_unref0 (self->priv->unit_sub_state_label);
	self->priv->unit_sub_state_label = _tmp64_;
	_tmp65_ = right_label_new (NULL);
	_tmp66_ = g_object_ref_sink (_tmp65_);
	_g_object_unref0 (self->priv->unit_fragment_path_label);
	self->priv->unit_fragment_path_label = _tmp66_;
	_tmp67_ = right_label_new (NULL);
	_tmp68_ = g_object_ref_sink (_tmp67_);
	_g_object_unref0 (self->priv->unit_active_enter_timestamp_label);
	self->priv->unit_active_enter_timestamp_label = _tmp68_;
	_tmp69_ = right_label_new (NULL);
	_tmp70_ = g_object_ref_sink (_tmp69_);
	_g_object_unref0 (self->priv->unit_active_exit_timestamp_label);
	self->priv->unit_active_exit_timestamp_label = _tmp70_;
	_tmp71_ = right_label_new (NULL);
	_tmp72_ = g_object_ref_sink (_tmp71_);
	_g_object_unref0 (self->priv->unit_can_start_label);
	self->priv->unit_can_start_label = _tmp72_;
	_tmp73_ = right_label_new (NULL);
	_tmp74_ = g_object_ref_sink (_tmp73_);
	_g_object_unref0 (self->priv->unit_can_reload_label);
	self->priv->unit_can_reload_label = _tmp74_;
	_tmp75_ = right_label_new (NULL);
	_tmp76_ = g_object_ref_sink (_tmp75_);
	_g_object_unref0 (self->priv->unit_cgroup_label);
	self->priv->unit_cgroup_label = _tmp76_;
	_tmp77_ = right_label_new (NULL);
	_tmp78_ = g_object_ref_sink (_tmp77_);
	_g_object_unref0 (self->priv->job_id_label);
	self->priv->job_id_label = _tmp78_;
	_tmp79_ = right_label_new (NULL);
	_tmp80_ = g_object_ref_sink (_tmp79_);
	_g_object_unref0 (self->priv->job_state_label);
	self->priv->job_state_label = _tmp80_;
	_tmp81_ = right_label_new (NULL);
	_tmp82_ = g_object_ref_sink (_tmp81_);
	_g_object_unref0 (self->priv->job_type_label);
	self->priv->job_type_label = _tmp82_;
	gtk_label_set_track_visited_links ((GtkLabel*) self->priv->unit_dependency_label, FALSE);
	gtk_label_set_selectable ((GtkLabel*) self->priv->unit_dependency_label, FALSE);
	g_signal_connect_object ((GtkLabel*) self->priv->unit_dependency_label, "activate-link", (GCallback) _main_window_on_activate_link_gtk_label_activate_link, self, 0);
	gtk_label_set_track_visited_links ((GtkLabel*) self->priv->unit_fragment_path_label, FALSE);
	_tmp83_ = (GtkTable*) gtk_table_new ((guint) 8, (guint) 6, FALSE);
	unit_table = g_object_ref_sink (_tmp83_);
	gtk_table_set_row_spacings (unit_table, (guint) 6);
	gtk_container_set_border_width ((GtkContainer*) unit_table, (guint) 0);
	gtk_box_pack_start (unit_vbox, (GtkWidget*) unit_table, FALSE, TRUE, (guint) 0);
	_tmp84_ = (GtkTable*) gtk_table_new ((guint) 2, (guint) 2, FALSE);
	job_table = g_object_ref_sink (_tmp84_);
	gtk_table_set_row_spacings (job_table, (guint) 6);
	gtk_container_set_border_width ((GtkContainer*) job_table, (guint) 0);
	gtk_box_pack_start (job_vbox, (GtkWidget*) job_table, FALSE, TRUE, (guint) 0);
	_tmp85_ = left_label_new ("Id:");
	_tmp86_ = g_object_ref_sink (_tmp85_);
	gtk_table_attach (unit_table, (GtkWidget*) _tmp86_, (guint) 0, (guint) 1, (guint) 0, (guint) 1, GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_g_object_unref0 (_tmp86_);
	gtk_table_attach (unit_table, (GtkWidget*) self->priv->unit_id_label, (guint) 1, (guint) 6, (guint) 0, (guint) 1, GTK_EXPAND | GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_tmp87_ = left_label_new ("Aliases:");
	_tmp88_ = g_object_ref_sink (_tmp87_);
	gtk_table_attach (unit_table, (GtkWidget*) _tmp88_, (guint) 0, (guint) 1, (guint) 1, (guint) 2, GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_g_object_unref0 (_tmp88_);
	gtk_table_attach (unit_table, (GtkWidget*) self->priv->unit_aliases_label, (guint) 1, (guint) 6, (guint) 1, (guint) 2, GTK_EXPAND | GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_tmp89_ = left_label_new ("Description:");
	_tmp90_ = g_object_ref_sink (_tmp89_);
	gtk_table_attach (unit_table, (GtkWidget*) _tmp90_, (guint) 0, (guint) 1, (guint) 2, (guint) 3, GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_g_object_unref0 (_tmp90_);
	gtk_table_attach (unit_table, (GtkWidget*) self->priv->unit_description_label, (guint) 1, (guint) 6, (guint) 2, (guint) 3, GTK_EXPAND | GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_tmp91_ = left_label_new ("Dependencies:");
	_tmp92_ = g_object_ref_sink (_tmp91_);
	gtk_table_attach (unit_table, (GtkWidget*) _tmp92_, (guint) 0, (guint) 1, (guint) 3, (guint) 4, GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_g_object_unref0 (_tmp92_);
	gtk_table_attach (unit_table, (GtkWidget*) self->priv->unit_dependency_label, (guint) 1, (guint) 6, (guint) 3, (guint) 4, GTK_EXPAND | GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_tmp93_ = left_label_new ("Fragment Path:");
	_tmp94_ = g_object_ref_sink (_tmp93_);
	gtk_table_attach (unit_table, (GtkWidget*) _tmp94_, (guint) 0, (guint) 1, (guint) 4, (guint) 5, GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_g_object_unref0 (_tmp94_);
	gtk_table_attach (unit_table, (GtkWidget*) self->priv->unit_fragment_path_label, (guint) 1, (guint) 6, (guint) 4, (guint) 5, GTK_EXPAND | GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_tmp95_ = left_label_new ("Control Group:");
	_tmp96_ = g_object_ref_sink (_tmp95_);
	gtk_table_attach (unit_table, (GtkWidget*) _tmp96_, (guint) 0, (guint) 1, (guint) 5, (guint) 6, GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_g_object_unref0 (_tmp96_);
	gtk_table_attach (unit_table, (GtkWidget*) self->priv->unit_cgroup_label, (guint) 1, (guint) 6, (guint) 5, (guint) 6, GTK_EXPAND | GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_tmp97_ = left_label_new ("Load State:");
	_tmp98_ = g_object_ref_sink (_tmp97_);
	gtk_table_attach (unit_table, (GtkWidget*) _tmp98_, (guint) 0, (guint) 1, (guint) 6, (guint) 7, GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_g_object_unref0 (_tmp98_);
	gtk_table_attach (unit_table, (GtkWidget*) self->priv->unit_load_state_label, (guint) 1, (guint) 2, (guint) 6, (guint) 7, GTK_EXPAND | GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_tmp99_ = left_label_new ("Active State:");
	_tmp100_ = g_object_ref_sink (_tmp99_);
	gtk_table_attach (unit_table, (GtkWidget*) _tmp100_, (guint) 0, (guint) 1, (guint) 7, (guint) 8, GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_g_object_unref0 (_tmp100_);
	gtk_table_attach (unit_table, (GtkWidget*) self->priv->unit_active_state_label, (guint) 1, (guint) 2, (guint) 7, (guint) 8, GTK_EXPAND | GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_tmp101_ = left_label_new ("Unit State:");
	_tmp102_ = g_object_ref_sink (_tmp101_);
	gtk_table_attach (unit_table, (GtkWidget*) _tmp102_, (guint) 0, (guint) 1, (guint) 8, (guint) 9, GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_g_object_unref0 (_tmp102_);
	gtk_table_attach (unit_table, (GtkWidget*) self->priv->unit_sub_state_label, (guint) 1, (guint) 2, (guint) 8, (guint) 9, GTK_EXPAND | GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_tmp103_ = left_label_new ("Active Enter Timestamp:");
	_tmp104_ = g_object_ref_sink (_tmp103_);
	gtk_table_attach (unit_table, (GtkWidget*) _tmp104_, (guint) 2, (guint) 3, (guint) 7, (guint) 8, GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_g_object_unref0 (_tmp104_);
	gtk_table_attach (unit_table, (GtkWidget*) self->priv->unit_active_enter_timestamp_label, (guint) 3, (guint) 4, (guint) 7, (guint) 8, GTK_EXPAND | GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_tmp105_ = left_label_new ("Active Exit Timestamp:");
	_tmp106_ = g_object_ref_sink (_tmp105_);
	gtk_table_attach (unit_table, (GtkWidget*) _tmp106_, (guint) 2, (guint) 3, (guint) 8, (guint) 9, GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_g_object_unref0 (_tmp106_);
	gtk_table_attach (unit_table, (GtkWidget*) self->priv->unit_active_exit_timestamp_label, (guint) 3, (guint) 4, (guint) 8, (guint) 9, GTK_EXPAND | GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_tmp107_ = left_label_new ("Can Start/Stop:");
	_tmp108_ = g_object_ref_sink (_tmp107_);
	gtk_table_attach (unit_table, (GtkWidget*) _tmp108_, (guint) 4, (guint) 5, (guint) 7, (guint) 8, GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_g_object_unref0 (_tmp108_);
	gtk_table_attach (unit_table, (GtkWidget*) self->priv->unit_can_start_label, (guint) 5, (guint) 6, (guint) 7, (guint) 8, GTK_EXPAND | GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_tmp109_ = left_label_new ("Can Reload:");
	_tmp110_ = g_object_ref_sink (_tmp109_);
	gtk_table_attach (unit_table, (GtkWidget*) _tmp110_, (guint) 4, (guint) 5, (guint) 8, (guint) 9, GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_g_object_unref0 (_tmp110_);
	gtk_table_attach (unit_table, (GtkWidget*) self->priv->unit_can_reload_label, (guint) 5, (guint) 6, (guint) 8, (guint) 9, GTK_EXPAND | GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_tmp111_ = left_label_new ("Id:");
	_tmp112_ = g_object_ref_sink (_tmp111_);
	gtk_table_attach (job_table, (GtkWidget*) _tmp112_, (guint) 0, (guint) 1, (guint) 0, (guint) 1, GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_g_object_unref0 (_tmp112_);
	gtk_table_attach (job_table, (GtkWidget*) self->priv->job_id_label, (guint) 1, (guint) 2, (guint) 0, (guint) 1, GTK_EXPAND | GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_tmp113_ = left_label_new ("State:");
	_tmp114_ = g_object_ref_sink (_tmp113_);
	gtk_table_attach (job_table, (GtkWidget*) _tmp114_, (guint) 0, (guint) 1, (guint) 1, (guint) 2, GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_g_object_unref0 (_tmp114_);
	gtk_table_attach (job_table, (GtkWidget*) self->priv->job_state_label, (guint) 1, (guint) 2, (guint) 1, (guint) 2, GTK_EXPAND | GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_tmp115_ = left_label_new ("Type:");
	_tmp116_ = g_object_ref_sink (_tmp115_);
	gtk_table_attach (job_table, (GtkWidget*) _tmp116_, (guint) 0, (guint) 1, (guint) 2, (guint) 3, GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_g_object_unref0 (_tmp116_);
	gtk_table_attach (job_table, (GtkWidget*) self->priv->job_type_label, (guint) 1, (guint) 2, (guint) 2, (guint) 3, GTK_EXPAND | GTK_FILL, GTK_FILL, (guint) 0, (guint) 0);
	_tmp117_ = (GtkHButtonBox*) gtk_hbutton_box_new ();
	bbox = (GtkButtonBox*) g_object_ref_sink (_tmp117_);
	gtk_button_box_set_layout (bbox, GTK_BUTTONBOX_START);
	gtk_box_set_spacing ((GtkBox*) bbox, 6);
	gtk_box_pack_start (unit_vbox, (GtkWidget*) bbox, FALSE, TRUE, (guint) 0);
	_tmp118_ = (GtkButton*) gtk_button_new_with_mnemonic ("_Start");
	_tmp119_ = g_object_ref_sink (_tmp118_);
	_g_object_unref0 (self->priv->start_button);
	self->priv->start_button = _tmp119_;
	_tmp120_ = (GtkButton*) gtk_button_new_with_mnemonic ("Sto_p");
	_tmp121_ = g_object_ref_sink (_tmp120_);
	_g_object_unref0 (self->priv->stop_button);
	self->priv->stop_button = _tmp121_;
	_tmp122_ = (GtkButton*) gtk_button_new_with_mnemonic ("_Reload");
	_tmp123_ = g_object_ref_sink (_tmp122_);
	_g_object_unref0 (self->priv->reload_button);
	self->priv->reload_button = _tmp123_;
	_tmp124_ = (GtkButton*) gtk_button_new_with_mnemonic ("Res_tart");
	_tmp125_ = g_object_ref_sink (_tmp124_);
	_g_object_unref0 (self->priv->restart_button);
	self->priv->restart_button = _tmp125_;
	g_signal_connect_object (self->priv->start_button, "clicked", (GCallback) _main_window_on_start_gtk_button_clicked, self, 0);
	g_signal_connect_object (self->priv->stop_button, "clicked", (GCallback) _main_window_on_stop_gtk_button_clicked, self, 0);
	g_signal_connect_object (self->priv->reload_button, "clicked", (GCallback) _main_window_on_reload_gtk_button_clicked, self, 0);
	g_signal_connect_object (self->priv->restart_button, "clicked", (GCallback) _main_window_on_restart_gtk_button_clicked, self, 0);
	gtk_box_pack_start ((GtkBox*) bbox, (GtkWidget*) self->priv->start_button, FALSE, TRUE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) bbox, (GtkWidget*) self->priv->stop_button, FALSE, TRUE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) bbox, (GtkWidget*) self->priv->restart_button, FALSE, TRUE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) bbox, (GtkWidget*) self->priv->reload_button, FALSE, TRUE, (guint) 0);
	_tmp126_ = (GtkHButtonBox*) gtk_hbutton_box_new ();
	_tmp127_ = (GtkButtonBox*) g_object_ref_sink (_tmp126_);
	_g_object_unref0 (bbox);
	bbox = _tmp127_;
	gtk_button_box_set_layout (bbox, GTK_BUTTONBOX_START);
	gtk_box_set_spacing ((GtkBox*) bbox, 6);
	gtk_box_pack_start (job_vbox, (GtkWidget*) bbox, FALSE, TRUE, (guint) 0);
	_tmp128_ = (GtkButton*) gtk_button_new_with_mnemonic ("_Cancel");
	_tmp129_ = g_object_ref_sink (_tmp128_);
	_g_object_unref0 (self->priv->cancel_button);
	self->priv->cancel_button = _tmp129_;
	g_signal_connect_object (self->priv->cancel_button, "clicked", (GCallback) _main_window_on_cancel_gtk_button_clicked, self, 0);
	gtk_box_pack_start ((GtkBox*) bbox, (GtkWidget*) self->priv->cancel_button, FALSE, TRUE, (guint) 0);
	if (user) {
		_tmp130_ = G_BUS_TYPE_SESSION;
	} else {
		_tmp130_ = G_BUS_TYPE_SYSTEM;
	}
	_tmp131_ = g_initable_new (TYPE_MANAGER_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "org.freedesktop.systemd1", "g-bus-type", _tmp130_, "g-object-path", "/org/freedesktop/systemd1", "g-interface-name", "org.freedesktop.systemd1.Manager", NULL);
	_tmp132_ = (Manager*) _tmp131_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (bbox);
			_g_object_unref0 (job_table);
			_g_object_unref0 (unit_table);
			_g_object_unref0 (scroll);
			_g_object_unref0 (unit_model_filter);
			_g_object_unref0 (unit_load_hbox);
			_g_object_unref0 (type_hbox);
			_g_object_unref0 (job_vbox);
			_g_object_unref0 (unit_vbox);
			_g_object_unref0 (notebook);
			_g_object_unref0 (self);
			return NULL;
		} else {
			_g_object_unref0 (bbox);
			_g_object_unref0 (job_table);
			_g_object_unref0 (unit_table);
			_g_object_unref0 (scroll);
			_g_object_unref0 (unit_model_filter);
			_g_object_unref0 (unit_load_hbox);
			_g_object_unref0 (type_hbox);
			_g_object_unref0 (job_vbox);
			_g_object_unref0 (unit_vbox);
			_g_object_unref0 (notebook);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp133_ = _tmp132_;
	_g_object_unref0 (self->priv->manager);
	self->priv->manager = _tmp133_;
	g_signal_connect_object (self->priv->manager, "unit-new", (GCallback) _main_window_on_unit_new_manager_unit_new, self, 0);
	g_signal_connect_object (self->priv->manager, "job-new", (GCallback) _main_window_on_job_new_manager_job_new, self, 0);
	g_signal_connect_object (self->priv->manager, "unit-removed", (GCallback) _main_window_on_unit_removed_manager_unit_removed, self, 0);
	g_signal_connect_object (self->priv->manager, "job-removed", (GCallback) _main_window_on_job_removed_manager_job_removed, self, 0);
	manager_subscribe (self->priv->manager, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (bbox);
			_g_object_unref0 (job_table);
			_g_object_unref0 (unit_table);
			_g_object_unref0 (scroll);
			_g_object_unref0 (unit_model_filter);
			_g_object_unref0 (unit_load_hbox);
			_g_object_unref0 (type_hbox);
			_g_object_unref0 (job_vbox);
			_g_object_unref0 (unit_vbox);
			_g_object_unref0 (notebook);
			_g_object_unref0 (self);
			return NULL;
		} else {
			_g_object_unref0 (bbox);
			_g_object_unref0 (job_table);
			_g_object_unref0 (unit_table);
			_g_object_unref0 (scroll);
			_g_object_unref0 (unit_model_filter);
			_g_object_unref0 (unit_load_hbox);
			_g_object_unref0 (type_hbox);
			_g_object_unref0 (job_vbox);
			_g_object_unref0 (unit_vbox);
			_g_object_unref0 (notebook);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	main_window_clear_unit (self);
	main_window_clear_job (self);
	main_window_populate_unit_model (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (bbox);
			_g_object_unref0 (job_table);
			_g_object_unref0 (unit_table);
			_g_object_unref0 (scroll);
			_g_object_unref0 (unit_model_filter);
			_g_object_unref0 (unit_load_hbox);
			_g_object_unref0 (type_hbox);
			_g_object_unref0 (job_vbox);
			_g_object_unref0 (unit_vbox);
			_g_object_unref0 (notebook);
			_g_object_unref0 (self);
			return NULL;
		} else {
			_g_object_unref0 (bbox);
			_g_object_unref0 (job_table);
			_g_object_unref0 (unit_table);
			_g_object_unref0 (scroll);
			_g_object_unref0 (unit_model_filter);
			_g_object_unref0 (unit_load_hbox);
			_g_object_unref0 (type_hbox);
			_g_object_unref0 (job_vbox);
			_g_object_unref0 (unit_vbox);
			_g_object_unref0 (notebook);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	main_window_populate_job_model (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (bbox);
			_g_object_unref0 (job_table);
			_g_object_unref0 (unit_table);
			_g_object_unref0 (scroll);
			_g_object_unref0 (unit_model_filter);
			_g_object_unref0 (unit_load_hbox);
			_g_object_unref0 (type_hbox);
			_g_object_unref0 (job_vbox);
			_g_object_unref0 (unit_vbox);
			_g_object_unref0 (notebook);
			_g_object_unref0 (self);
			return NULL;
		} else {
			_g_object_unref0 (bbox);
			_g_object_unref0 (job_table);
			_g_object_unref0 (unit_table);
			_g_object_unref0 (scroll);
			_g_object_unref0 (unit_model_filter);
			_g_object_unref0 (unit_load_hbox);
			_g_object_unref0 (type_hbox);
			_g_object_unref0 (job_vbox);
			_g_object_unref0 (unit_vbox);
			_g_object_unref0 (notebook);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_g_object_unref0 (bbox);
	_g_object_unref0 (job_table);
	_g_object_unref0 (unit_table);
	_g_object_unref0 (scroll);
	_g_object_unref0 (unit_model_filter);
	_g_object_unref0 (unit_load_hbox);
	_g_object_unref0 (type_hbox);
	_g_object_unref0 (job_vbox);
	_g_object_unref0 (unit_vbox);
	_g_object_unref0 (notebook);
	return self;
}


MainWindow* main_window_new (GError** error) {
	return main_window_construct (TYPE_MAIN_WINDOW, error);
}


static void _vala_ManagerUnitInfo_array_free (ManagerUnitInfo* array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			manager_unit_info_destroy (&array[i]);
		}
	}
	g_free (array);
}


static void _main_window_on_unit_changed_properties_properties_changed (Properties* _sender, const gchar* iface, GHashTable* changed_properties, gchar** invalidated_properties, int invalidated_properties_length1, gpointer self) {
	main_window_on_unit_changed (self, _sender, iface, changed_properties, invalidated_properties, invalidated_properties_length1);
}


void main_window_populate_unit_model (MainWindow* self, GError** error) {
	gint _tmp0_;
	ManagerUnitInfo* _tmp1_ = NULL;
	ManagerUnitInfo* list;
	gint list_length1;
	gint _list_size_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	gtk_list_store_clear (self->priv->unit_model);
	_tmp1_ = manager_list_units (self->priv->manager, &_tmp0_, &_inner_error_);
	list = _tmp1_;
	list_length1 = _tmp0_;
	_list_size_ = _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	{
		ManagerUnitInfo* i_collection;
		int i_collection_length1;
		int i_it;
		i_collection = list;
		i_collection_length1 = list_length1;
		for (i_it = 0; i_it < list_length1; i_it = i_it + 1) {
			ManagerUnitInfo _tmp2_;
			ManagerUnitInfo _tmp3_ = {0};
			ManagerUnitInfo i;
			_tmp2_ = (manager_unit_info_copy (&i_collection[i_it], &_tmp3_), _tmp3_);
			i = _tmp2_;
			{
				GtkTreeIter iter = {0};
				GBusType _tmp4_ = 0;
				Properties* _tmp5_ = NULL;
				Properties* p;
				GBusType _tmp6_ = 0;
				Unit* _tmp7_ = NULL;
				Unit* u;
				GtkTreeIter _tmp8_ = {0};
				gchar* _tmp9_ = NULL;
				if (user) {
					_tmp4_ = G_BUS_TYPE_SESSION;
				} else {
					_tmp4_ = G_BUS_TYPE_SYSTEM;
				}
				_tmp5_ = g_initable_new (TYPE_PROPERTIES_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "org.freedesktop.systemd1", "g-bus-type", _tmp4_, "g-object-path", (const gchar*) i.unit_path, "g-interface-name", "org.freedesktop.Properties", NULL);
				p = (Properties*) _tmp5_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == G_IO_ERROR) {
						g_propagate_error (error, _inner_error_);
						manager_unit_info_destroy (&i);
						list = (_vala_ManagerUnitInfo_array_free (list, list_length1), NULL);
						return;
					} else {
						manager_unit_info_destroy (&i);
						list = (_vala_ManagerUnitInfo_array_free (list, list_length1), NULL);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				g_signal_connect_object (p, "properties-changed", (GCallback) _main_window_on_unit_changed_properties_properties_changed, self, 0);
				if (user) {
					_tmp6_ = G_BUS_TYPE_SESSION;
				} else {
					_tmp6_ = G_BUS_TYPE_SYSTEM;
				}
				_tmp7_ = g_initable_new (TYPE_UNIT_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "org.freedesktop.systemd1", "g-bus-type", _tmp6_, "g-object-path", (const gchar*) i.unit_path, "g-interface-name", "org.freedesktop.systemd1.Unit", NULL);
				u = (Unit*) _tmp7_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == G_IO_ERROR) {
						g_propagate_error (error, _inner_error_);
						_g_object_unref0 (p);
						manager_unit_info_destroy (&i);
						list = (_vala_ManagerUnitInfo_array_free (list, list_length1), NULL);
						return;
					} else {
						_g_object_unref0 (p);
						manager_unit_info_destroy (&i);
						list = (_vala_ManagerUnitInfo_array_free (list, list_length1), NULL);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				gtk_list_store_append (self->priv->unit_model, &_tmp8_);
				iter = _tmp8_;
				if (g_strcmp0 (i.job_type, "") != 0) {
					gchar* _tmp10_ = NULL;
					gchar* _tmp11_;
					_tmp10_ = g_strdup_printf ("→ %s", i.job_type);
					_tmp11_ = _tmp10_;
					_g_free0 (_tmp9_);
					_tmp9_ = _tmp11_;
				} else {
					gchar* _tmp12_;
					gchar* _tmp13_;
					_tmp12_ = g_strdup ("");
					_tmp13_ = _tmp12_;
					_g_free0 (_tmp9_);
					_tmp9_ = _tmp13_;
				}
				gtk_list_store_set (self->priv->unit_model, &iter, 0, i.id, 1, i.description, 2, i.load_state, 3, i.active_state, 4, i.sub_state, 5, _tmp9_, 6, u, -1);
				_g_free0 (_tmp9_);
				_g_object_unref0 (u);
				_g_object_unref0 (p);
				manager_unit_info_destroy (&i);
			}
		}
	}
	list = (_vala_ManagerUnitInfo_array_free (list, list_length1), NULL);
}


static void _vala_ManagerJobInfo_array_free (ManagerJobInfo* array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			manager_job_info_destroy (&array[i]);
		}
	}
	g_free (array);
}


static void _main_window_on_job_changed_properties_properties_changed (Properties* _sender, const gchar* iface, GHashTable* changed_properties, gchar** invalidated_properties, int invalidated_properties_length1, gpointer self) {
	main_window_on_job_changed (self, _sender, iface, changed_properties, invalidated_properties, invalidated_properties_length1);
}


void main_window_populate_job_model (MainWindow* self, GError** error) {
	gint _tmp0_;
	ManagerJobInfo* _tmp1_ = NULL;
	ManagerJobInfo* list;
	gint list_length1;
	gint _list_size_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	gtk_list_store_clear (self->priv->job_model);
	_tmp1_ = manager_list_jobs (self->priv->manager, &_tmp0_, &_inner_error_);
	list = _tmp1_;
	list_length1 = _tmp0_;
	_list_size_ = _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	{
		ManagerJobInfo* i_collection;
		int i_collection_length1;
		int i_it;
		i_collection = list;
		i_collection_length1 = list_length1;
		for (i_it = 0; i_it < list_length1; i_it = i_it + 1) {
			ManagerJobInfo _tmp2_;
			ManagerJobInfo _tmp3_ = {0};
			ManagerJobInfo i;
			_tmp2_ = (manager_job_info_copy (&i_collection[i_it], &_tmp3_), _tmp3_);
			i = _tmp2_;
			{
				GtkTreeIter iter = {0};
				GBusType _tmp4_ = 0;
				Properties* _tmp5_ = NULL;
				Properties* p;
				GBusType _tmp6_ = 0;
				Job* _tmp7_ = NULL;
				Job* j;
				GtkTreeIter _tmp8_ = {0};
				gchar* _tmp9_ = NULL;
				gchar* _tmp10_;
				gchar* _tmp11_ = NULL;
				gchar* _tmp12_;
				if (user) {
					_tmp4_ = G_BUS_TYPE_SESSION;
				} else {
					_tmp4_ = G_BUS_TYPE_SYSTEM;
				}
				_tmp5_ = g_initable_new (TYPE_PROPERTIES_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "org.freedesktop.systemd1", "g-bus-type", _tmp4_, "g-object-path", (const gchar*) i.job_path, "g-interface-name", "org.freedesktop.Properties", NULL);
				p = (Properties*) _tmp5_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == G_IO_ERROR) {
						g_propagate_error (error, _inner_error_);
						manager_job_info_destroy (&i);
						list = (_vala_ManagerJobInfo_array_free (list, list_length1), NULL);
						return;
					} else {
						manager_job_info_destroy (&i);
						list = (_vala_ManagerJobInfo_array_free (list, list_length1), NULL);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				g_signal_connect_object (p, "properties-changed", (GCallback) _main_window_on_job_changed_properties_properties_changed, self, 0);
				if (user) {
					_tmp6_ = G_BUS_TYPE_SESSION;
				} else {
					_tmp6_ = G_BUS_TYPE_SYSTEM;
				}
				_tmp7_ = g_initable_new (TYPE_JOB_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "org.freedesktop.systemd1", "g-bus-type", _tmp6_, "g-object-path", (const gchar*) i.job_path, "g-interface-name", "org.freedesktop.systemd1.Job", NULL);
				j = (Job*) _tmp7_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == G_IO_ERROR) {
						g_propagate_error (error, _inner_error_);
						_g_object_unref0 (p);
						manager_job_info_destroy (&i);
						list = (_vala_ManagerJobInfo_array_free (list, list_length1), NULL);
						return;
					} else {
						_g_object_unref0 (p);
						manager_job_info_destroy (&i);
						list = (_vala_ManagerJobInfo_array_free (list, list_length1), NULL);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				gtk_list_store_append (self->priv->job_model, &_tmp8_);
				iter = _tmp8_;
				_tmp9_ = g_strdup_printf ("%u", (guint) i.id);
				_tmp10_ = _tmp9_;
				_tmp11_ = g_strdup_printf ("→ %s", i.type);
				_tmp12_ = _tmp11_;
				gtk_list_store_set (self->priv->job_model, &iter, 0, _tmp10_, 1, i.name, 2, _tmp12_, 3, i.state, 4, j, 5, i.id, -1);
				_g_free0 (_tmp12_);
				_g_free0 (_tmp10_);
				_g_object_unref0 (j);
				_g_object_unref0 (p);
				manager_job_info_destroy (&i);
			}
		}
	}
	list = (_vala_ManagerJobInfo_array_free (list, list_length1), NULL);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


Unit* main_window_get_current_unit (MainWindow* self) {
	Unit* result = NULL;
	GtkTreePath* p = NULL;
	GtkTreePath* _tmp0_ = NULL;
	GtkTreeModel* _tmp1_ = NULL;
	GtkTreeModel* _tmp2_;
	GtkTreeModel* model;
	GtkTreeIter iter = {0};
	Unit* u = NULL;
	GtkTreeIter _tmp3_ = {0};
	g_return_val_if_fail (self != NULL, NULL);
	gtk_tree_view_get_cursor (self->priv->unit_view, &_tmp0_, NULL);
	_gtk_tree_path_free0 (p);
	p = _tmp0_;
	if (p == NULL) {
		result = NULL;
		_gtk_tree_path_free0 (p);
		return result;
	}
	_tmp1_ = gtk_tree_view_get_model (self->priv->unit_view);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	model = _tmp2_;
	gtk_tree_model_get_iter (model, &_tmp3_, p);
	iter = _tmp3_;
	gtk_tree_model_get (model, &iter, 6, &u, -1);
	result = u;
	_g_object_unref0 (model);
	_gtk_tree_path_free0 (p);
	return result;
}


void main_window_unit_changed (MainWindow* self) {
	Unit* _tmp0_ = NULL;
	Unit* u;
	g_return_if_fail (self != NULL);
	_tmp0_ = main_window_get_current_unit (self);
	u = _tmp0_;
	if (u == NULL) {
		main_window_clear_unit (self);
	} else {
		main_window_show_unit (self, u);
	}
	_g_object_unref0 (u);
}


void main_window_clear_unit (MainWindow* self) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = NULL;
	_g_free0 (self->priv->current_unit_id);
	self->priv->current_unit_id = _tmp0_;
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->start_button, FALSE);
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->stop_button, FALSE);
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->reload_button, FALSE);
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->restart_button, FALSE);
	right_label_set_text_or_na (self->priv->unit_id_label, NULL);
	right_label_set_text_or_na (self->priv->unit_aliases_label, NULL);
	right_label_set_text_or_na (self->priv->unit_description_label, NULL);
	right_label_set_text_or_na (self->priv->unit_description_label, NULL);
	right_label_set_text_or_na (self->priv->unit_load_state_label, NULL);
	right_label_set_text_or_na (self->priv->unit_active_state_label, NULL);
	right_label_set_text_or_na (self->priv->unit_sub_state_label, NULL);
	right_label_set_text_or_na (self->priv->unit_fragment_path_label, NULL);
	right_label_set_text_or_na (self->priv->unit_active_enter_timestamp_label, NULL);
	right_label_set_text_or_na (self->priv->unit_active_exit_timestamp_label, NULL);
	right_label_set_text_or_na (self->priv->unit_can_reload_label, NULL);
	right_label_set_text_or_na (self->priv->unit_can_start_label, NULL);
	right_label_set_text_or_na (self->priv->unit_cgroup_label, NULL);
}


gchar* main_window_make_dependency_string (MainWindow* self, const gchar* prefix, const gchar* word, gchar** dependencies, int dependencies_length1) {
	gchar* result = NULL;
	gboolean first;
	gchar* r = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (word != NULL, NULL);
	first = TRUE;
	if (prefix == NULL) {
		gchar* _tmp0_;
		gchar* _tmp1_;
		_tmp0_ = g_strdup ("");
		_tmp1_ = _tmp0_;
		_g_free0 (r);
		r = _tmp1_;
	} else {
		gchar* _tmp2_;
		gchar* _tmp3_;
		_tmp2_ = g_strdup (prefix);
		_tmp3_ = _tmp2_;
		_g_free0 (r);
		r = _tmp3_;
	}
	{
		gchar** i_collection;
		int i_collection_length1;
		int i_it;
		i_collection = dependencies;
		i_collection_length1 = dependencies_length1;
		for (i_it = 0; i_it < dependencies_length1; i_it = i_it + 1) {
			gchar* _tmp4_;
			gchar* i;
			_tmp4_ = g_strdup (i_collection[i_it]);
			i = _tmp4_;
			{
				gchar* _tmp8_;
				gchar* _tmp9_;
				gchar* _tmp10_;
				gchar* _tmp11_;
				gchar* _tmp12_;
				if (g_strcmp0 (r, "") != 0) {
					const gchar* _tmp5_ = NULL;
					gchar* _tmp6_;
					if (first) {
						_tmp5_ = "\n";
					} else {
						_tmp5_ = ",";
					}
					_tmp6_ = g_strconcat (r, _tmp5_, NULL);
					_g_free0 (r);
					r = _tmp6_;
				}
				if (first) {
					gchar* _tmp7_;
					_tmp7_ = g_strconcat (r, word, NULL);
					_g_free0 (r);
					r = _tmp7_;
					first = FALSE;
				}
				_tmp8_ = g_strconcat (" <a href=\"", i, NULL);
				_tmp9_ = g_strconcat (_tmp8_, "\">", NULL);
				_tmp10_ = g_strconcat (_tmp9_, i, NULL);
				_tmp11_ = g_strconcat (_tmp10_, "</a>", NULL);
				_tmp12_ = g_strconcat (r, _tmp11_, NULL);
				_g_free0 (r);
				r = _tmp12_;
				_g_free0 (_tmp11_);
				_g_free0 (_tmp10_);
				_g_free0 (_tmp9_);
				_g_free0 (_tmp8_);
				_g_free0 (i);
			}
		}
	}
	result = r;
	return result;
}


static void g_time_local (time_t time, struct tm* result) {
	struct tm _result_ = {0};
	struct tm _tmp0_ = {0};
	localtime_r (&time, &_tmp0_);
	_result_ = _tmp0_;
	*result = _result_;
	return;
}


static gchar* g_time_format (struct tm *self, const gchar* format) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* buffer;
	gint buffer_length1;
	gint _buffer_size_;
	gchar* _tmp1_;
	g_return_val_if_fail (format != NULL, NULL);
	_tmp0_ = g_new0 (gchar, 64);
	buffer = _tmp0_;
	buffer_length1 = 64;
	_buffer_size_ = 64;
	strftime (buffer, buffer_length1, format, &(*self));
	_tmp1_ = g_strdup ((const gchar*) buffer);
	result = _tmp1_;
	buffer = (g_free (buffer), NULL);
	return result;
}


void main_window_show_unit (MainWindow* self, Unit* unit) {
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* a;
	gchar** _tmp3_ = NULL;
	gint _tmp4_;
	gchar** _tmp10_ = NULL;
	gint _tmp11_;
	gchar** requires;
	gint requires_length1;
	gint _requires_size_;
	gchar** _tmp12_ = NULL;
	gint _tmp13_;
	gchar** requires_overridable;
	gint requires_overridable_length1;
	gint _requires_overridable_size_;
	gchar** _tmp14_ = NULL;
	gint _tmp15_;
	gchar** requisite;
	gint requisite_length1;
	gint _requisite_size_;
	gchar** _tmp16_ = NULL;
	gint _tmp17_;
	gchar** requisite_overridable;
	gint requisite_overridable_length1;
	gint _requisite_overridable_size_;
	gchar** _tmp18_ = NULL;
	gint _tmp19_;
	gchar** wants;
	gint wants_length1;
	gint _wants_size_;
	gchar** _tmp20_ = NULL;
	gint _tmp21_;
	gchar** required_by;
	gint required_by_length1;
	gint _required_by_size_;
	gchar** _tmp22_ = NULL;
	gint _tmp23_;
	gchar** required_by_overridable;
	gint required_by_overridable_length1;
	gint _required_by_overridable_size_;
	gchar** _tmp24_ = NULL;
	gint _tmp25_;
	gchar** wanted_by;
	gint wanted_by_length1;
	gint _wanted_by_size_;
	gchar** _tmp26_ = NULL;
	gint _tmp27_;
	gchar** conflicts;
	gint conflicts_length1;
	gint _conflicts_size_;
	gchar** _tmp28_ = NULL;
	gint _tmp29_;
	gchar** before;
	gint before_length1;
	gint _before_size_;
	gchar** _tmp30_ = NULL;
	gint _tmp31_;
	gchar** after;
	gint after_length1;
	gint _after_size_;
	gchar* _tmp32_ = NULL;
	gchar* _tmp33_;
	gchar* _tmp34_ = NULL;
	gchar* _tmp35_;
	gchar* _tmp36_ = NULL;
	gchar* _tmp37_;
	gchar* _tmp38_ = NULL;
	gchar* _tmp39_;
	gchar* _tmp40_ = NULL;
	gchar* _tmp41_;
	gchar* _tmp42_ = NULL;
	gchar* _tmp43_;
	gchar* _tmp44_ = NULL;
	gchar* _tmp45_;
	gchar* _tmp46_ = NULL;
	gchar* _tmp47_;
	gchar* _tmp48_ = NULL;
	gchar* _tmp49_;
	gchar* _tmp50_ = NULL;
	gchar* _tmp51_;
	gchar* _tmp52_ = NULL;
	gchar* _tmp53_;
	gchar* _tmp54_ = NULL;
	gchar* _tmp55_;
	gchar* _tmp56_ = NULL;
	gchar* _tmp57_;
	gchar* _tmp58_ = NULL;
	gchar* _tmp59_;
	gchar* _tmp60_ = NULL;
	gchar* _tmp61_;
	gchar* _tmp62_ = NULL;
	gchar* fp;
	guint64 _tmp67_;
	guint64 t;
	guint64 _tmp72_;
	gboolean _tmp77_;
	gboolean b;
	const gchar* _tmp78_ = NULL;
	gboolean _tmp79_;
	const gchar* _tmp80_ = NULL;
	gchar* _tmp81_ = NULL;
	gchar* _tmp82_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (unit != NULL);
	_tmp0_ = unit_get_id (unit);
	_tmp1_ = _tmp0_;
	_g_free0 (self->priv->current_unit_id);
	self->priv->current_unit_id = _tmp1_;
	right_label_set_text_or_na (self->priv->unit_id_label, self->priv->current_unit_id);
	_tmp2_ = g_strdup ("");
	a = _tmp2_;
	_tmp3_ = unit_get_names (unit, &_tmp4_);
	{
		gchar** i_collection;
		int i_collection_length1;
		int i_it;
		i_collection = _tmp3_;
		i_collection_length1 = _tmp4_;
		for (i_it = 0; i_it < _tmp4_; i_it = i_it + 1) {
			gchar* _tmp5_;
			gchar* i;
			_tmp5_ = g_strdup (i_collection[i_it]);
			i = _tmp5_;
			{
				if (g_strcmp0 (i, self->priv->current_unit_id) == 0) {
					_g_free0 (i);
					continue;
				}
				if (g_strcmp0 (a, "") == 0) {
					gchar* _tmp6_;
					gchar* _tmp7_;
					_tmp6_ = g_strdup (i);
					_tmp7_ = _tmp6_;
					_g_free0 (a);
					a = _tmp7_;
				} else {
					gchar* _tmp8_;
					gchar* _tmp9_;
					_tmp8_ = g_strconcat ("\n", i, NULL);
					_tmp9_ = g_strconcat (a, _tmp8_, NULL);
					_g_free0 (a);
					a = _tmp9_;
					_g_free0 (_tmp8_);
				}
				_g_free0 (i);
			}
		}
		i_collection = (_vala_array_free (i_collection, i_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	right_label_set_text_or_na (self->priv->unit_aliases_label, a);
	_tmp10_ = unit_get_requires (unit, &_tmp11_);
	requires = _tmp10_;
	requires_length1 = _tmp11_;
	_requires_size_ = _tmp11_;
	_tmp12_ = unit_get_requires_overridable (unit, &_tmp13_);
	requires_overridable = _tmp12_;
	requires_overridable_length1 = _tmp13_;
	_requires_overridable_size_ = _tmp13_;
	_tmp14_ = unit_get_requisite (unit, &_tmp15_);
	requisite = _tmp14_;
	requisite_length1 = _tmp15_;
	_requisite_size_ = _tmp15_;
	_tmp16_ = unit_get_requisite_overridable (unit, &_tmp17_);
	requisite_overridable = _tmp16_;
	requisite_overridable_length1 = _tmp17_;
	_requisite_overridable_size_ = _tmp17_;
	_tmp18_ = unit_get_wants (unit, &_tmp19_);
	wants = _tmp18_;
	wants_length1 = _tmp19_;
	_wants_size_ = _tmp19_;
	_tmp20_ = unit_get_required_by (unit, &_tmp21_);
	required_by = _tmp20_;
	required_by_length1 = _tmp21_;
	_required_by_size_ = _tmp21_;
	_tmp22_ = unit_get_required_by_overridable (unit, &_tmp23_);
	required_by_overridable = _tmp22_;
	required_by_overridable_length1 = _tmp23_;
	_required_by_overridable_size_ = _tmp23_;
	_tmp24_ = unit_get_wanted_by (unit, &_tmp25_);
	wanted_by = _tmp24_;
	wanted_by_length1 = _tmp25_;
	_wanted_by_size_ = _tmp25_;
	_tmp26_ = unit_get_conflicts (unit, &_tmp27_);
	conflicts = _tmp26_;
	conflicts_length1 = _tmp27_;
	_conflicts_size_ = _tmp27_;
	_tmp28_ = unit_get_before (unit, &_tmp29_);
	before = _tmp28_;
	before_length1 = _tmp29_;
	_before_size_ = _tmp29_;
	_tmp30_ = unit_get_after (unit, &_tmp31_);
	after = _tmp30_;
	after_length1 = _tmp31_;
	_after_size_ = _tmp31_;
	_tmp32_ = main_window_make_dependency_string (self, NULL, "requires", requires, requires_length1);
	_tmp33_ = _tmp32_;
	_tmp34_ = main_window_make_dependency_string (self, _tmp33_, "overridable requires", requires_overridable, requires_overridable_length1);
	_tmp35_ = _tmp34_;
	_tmp36_ = main_window_make_dependency_string (self, _tmp35_, "requisite", requisite, requisite_length1);
	_tmp37_ = _tmp36_;
	_tmp38_ = main_window_make_dependency_string (self, _tmp37_, "overridable requisite", requisite_overridable, requisite_overridable_length1);
	_tmp39_ = _tmp38_;
	_tmp40_ = main_window_make_dependency_string (self, _tmp39_, "wants", wants, wants_length1);
	_tmp41_ = _tmp40_;
	_tmp42_ = main_window_make_dependency_string (self, _tmp41_, "conflicts", conflicts, conflicts_length1);
	_tmp43_ = _tmp42_;
	_tmp44_ = main_window_make_dependency_string (self, _tmp43_, "required by", required_by, required_by_length1);
	_tmp45_ = _tmp44_;
	_tmp46_ = main_window_make_dependency_string (self, _tmp45_, "overridable required by", required_by_overridable, required_by_overridable_length1);
	_tmp47_ = _tmp46_;
	_tmp48_ = main_window_make_dependency_string (self, _tmp47_, "wanted by", wanted_by, wanted_by_length1);
	_tmp49_ = _tmp48_;
	_tmp50_ = main_window_make_dependency_string (self, _tmp49_, "after", after, after_length1);
	_tmp51_ = _tmp50_;
	_tmp52_ = main_window_make_dependency_string (self, _tmp51_, "before", before, before_length1);
	_tmp53_ = _tmp52_;
	right_label_set_markup_or_na (self->priv->unit_dependency_label, _tmp53_);
	_g_free0 (_tmp53_);
	_g_free0 (_tmp51_);
	_g_free0 (_tmp49_);
	_g_free0 (_tmp47_);
	_g_free0 (_tmp45_);
	_g_free0 (_tmp43_);
	_g_free0 (_tmp41_);
	_g_free0 (_tmp39_);
	_g_free0 (_tmp37_);
	_g_free0 (_tmp35_);
	_g_free0 (_tmp33_);
	_tmp54_ = unit_get_description (unit);
	_tmp55_ = _tmp54_;
	right_label_set_text_or_na (self->priv->unit_description_label, _tmp55_);
	_g_free0 (_tmp55_);
	_tmp56_ = unit_get_load_state (unit);
	_tmp57_ = _tmp56_;
	right_label_set_text_or_na (self->priv->unit_load_state_label, _tmp57_);
	_g_free0 (_tmp57_);
	_tmp58_ = unit_get_active_state (unit);
	_tmp59_ = _tmp58_;
	right_label_set_text_or_na (self->priv->unit_active_state_label, _tmp59_);
	_g_free0 (_tmp59_);
	_tmp60_ = unit_get_sub_state (unit);
	_tmp61_ = _tmp60_;
	right_label_set_text_or_na (self->priv->unit_sub_state_label, _tmp61_);
	_g_free0 (_tmp61_);
	_tmp62_ = unit_get_fragment_path (unit);
	fp = _tmp62_;
	if (g_strcmp0 (fp, "") != 0) {
		gchar* _tmp63_;
		gchar* _tmp64_;
		gchar* _tmp65_;
		gchar* _tmp66_;
		_tmp63_ = g_strconcat ("<a href=\"file://", fp, NULL);
		_tmp64_ = g_strconcat (_tmp63_, "\">", NULL);
		_tmp65_ = g_strconcat (_tmp64_, fp, NULL);
		_tmp66_ = g_strconcat (_tmp65_, "</a>", NULL);
		right_label_set_markup_or_na (self->priv->unit_fragment_path_label, _tmp66_);
		_g_free0 (_tmp66_);
		_g_free0 (_tmp65_);
		_g_free0 (_tmp64_);
		_g_free0 (_tmp63_);
	} else {
		right_label_set_text_or_na (self->priv->unit_fragment_path_label, NULL);
	}
	_tmp67_ = unit_get_active_enter_timestamp (unit);
	t = _tmp67_;
	if (t > 0) {
		struct tm _tmp68_ = {0};
		struct tm _tmp69_ = {0};
		struct tm timestamp;
		gchar* _tmp70_ = NULL;
		gchar* _tmp71_;
		_tmp69_ = (g_time_local ((time_t) (t / 1000000), &_tmp68_), _tmp68_);
		timestamp = _tmp69_;
		_tmp70_ = g_time_format (&timestamp, "%a, %d %b %Y %H:%M:%S %z");
		_tmp71_ = _tmp70_;
		right_label_set_text_or_na (self->priv->unit_active_enter_timestamp_label, _tmp71_);
		_g_free0 (_tmp71_);
	} else {
		right_label_set_text_or_na (self->priv->unit_active_enter_timestamp_label, NULL);
	}
	_tmp72_ = unit_get_active_exit_timestamp (unit);
	t = _tmp72_;
	if (t > 0) {
		struct tm _tmp73_ = {0};
		struct tm _tmp74_ = {0};
		struct tm timestamp;
		gchar* _tmp75_ = NULL;
		gchar* _tmp76_;
		_tmp74_ = (g_time_local ((time_t) (t / 1000000), &_tmp73_), _tmp73_);
		timestamp = _tmp74_;
		_tmp75_ = g_time_format (&timestamp, "%a, %d %b %Y %H:%M:%S %z");
		_tmp76_ = _tmp75_;
		right_label_set_text_or_na (self->priv->unit_active_exit_timestamp_label, _tmp76_);
		_g_free0 (_tmp76_);
	} else {
		right_label_set_text_or_na (self->priv->unit_active_exit_timestamp_label, NULL);
	}
	_tmp77_ = unit_get_can_start (unit);
	b = _tmp77_;
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->start_button, b);
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->stop_button, b);
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->restart_button, b);
	if (b) {
		_tmp78_ = "Yes";
	} else {
		_tmp78_ = "No";
	}
	right_label_set_text_or_na (self->priv->unit_can_start_label, _tmp78_);
	_tmp79_ = unit_get_can_reload (unit);
	b = _tmp79_;
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->reload_button, b);
	if (b) {
		_tmp80_ = "Yes";
	} else {
		_tmp80_ = "No";
	}
	right_label_set_text_or_na (self->priv->unit_can_reload_label, _tmp80_);
	_tmp81_ = unit_get_default_control_group (unit);
	_tmp82_ = _tmp81_;
	right_label_set_text_or_na (self->priv->unit_cgroup_label, _tmp82_);
	_g_free0 (_tmp82_);
	_g_free0 (fp);
	after = (_vala_array_free (after, after_length1, (GDestroyNotify) g_free), NULL);
	before = (_vala_array_free (before, before_length1, (GDestroyNotify) g_free), NULL);
	conflicts = (_vala_array_free (conflicts, conflicts_length1, (GDestroyNotify) g_free), NULL);
	wanted_by = (_vala_array_free (wanted_by, wanted_by_length1, (GDestroyNotify) g_free), NULL);
	required_by_overridable = (_vala_array_free (required_by_overridable, required_by_overridable_length1, (GDestroyNotify) g_free), NULL);
	required_by = (_vala_array_free (required_by, required_by_length1, (GDestroyNotify) g_free), NULL);
	wants = (_vala_array_free (wants, wants_length1, (GDestroyNotify) g_free), NULL);
	requisite_overridable = (_vala_array_free (requisite_overridable, requisite_overridable_length1, (GDestroyNotify) g_free), NULL);
	requisite = (_vala_array_free (requisite, requisite_length1, (GDestroyNotify) g_free), NULL);
	requires_overridable = (_vala_array_free (requires_overridable, requires_overridable_length1, (GDestroyNotify) g_free), NULL);
	requires = (_vala_array_free (requires, requires_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (a);
}


Job* main_window_get_current_job (MainWindow* self) {
	Job* result = NULL;
	GtkTreePath* p = NULL;
	GtkTreePath* _tmp0_ = NULL;
	GtkTreeIter iter = {0};
	GtkTreeModel* _tmp1_ = NULL;
	GtkTreeModel* _tmp2_;
	GtkTreeModel* model;
	Job* j = NULL;
	GtkTreeIter _tmp3_ = {0};
	Job* _tmp4_;
	g_return_val_if_fail (self != NULL, NULL);
	gtk_tree_view_get_cursor (self->priv->job_view, &_tmp0_, NULL);
	_gtk_tree_path_free0 (p);
	p = _tmp0_;
	if (p == NULL) {
		result = NULL;
		_gtk_tree_path_free0 (p);
		return result;
	}
	_tmp1_ = gtk_tree_view_get_model (self->priv->job_view);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	model = _tmp2_;
	gtk_tree_model_get_iter (model, &_tmp3_, p);
	iter = _tmp3_;
	gtk_tree_model_get (model, &iter, 4, &j, -1);
	_tmp4_ = _g_object_ref0 (j);
	result = _tmp4_;
	_g_object_unref0 (model);
	_gtk_tree_path_free0 (p);
	return result;
}


void main_window_job_changed (MainWindow* self) {
	Job* _tmp0_ = NULL;
	Job* j;
	g_return_if_fail (self != NULL);
	_tmp0_ = main_window_get_current_job (self);
	j = _tmp0_;
	if (j == NULL) {
		main_window_clear_job (self);
	} else {
		main_window_show_job (self, j);
	}
	_g_object_unref0 (j);
}


void main_window_clear_job (MainWindow* self) {
	g_return_if_fail (self != NULL);
	self->priv->current_job_id = (guint32) 0;
	right_label_set_text_or_na (self->priv->job_id_label, NULL);
	right_label_set_text_or_na (self->priv->job_state_label, NULL);
	right_label_set_text_or_na (self->priv->job_type_label, NULL);
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->cancel_button, FALSE);
}


void main_window_show_job (MainWindow* self, Job* job) {
	guint32 _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (job != NULL);
	_tmp0_ = job_get_id (job);
	self->priv->current_job_id = _tmp0_;
	_tmp1_ = g_strdup_printf ("%u", (guint) self->priv->current_job_id);
	_tmp2_ = _tmp1_;
	right_label_set_text_or_na (self->priv->job_id_label, _tmp2_);
	_g_free0 (_tmp2_);
	_tmp3_ = job_get_state (job);
	_tmp4_ = _tmp3_;
	right_label_set_text_or_na (self->priv->job_state_label, _tmp4_);
	_g_free0 (_tmp4_);
	_tmp5_ = job_get_job_type (job);
	_tmp6_ = _tmp5_;
	right_label_set_text_or_na (self->priv->job_type_label, _tmp6_);
	_g_free0 (_tmp6_);
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->cancel_button, TRUE);
}


void main_window_on_start (MainWindow* self) {
	Unit* _tmp0_ = NULL;
	Unit* u;
	char* _tmp1_ = NULL;
	char* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = main_window_get_current_unit (self);
	u = _tmp0_;
	if (u == NULL) {
		_g_object_unref0 (u);
		return;
	}
	_tmp1_ = unit_start (u, "replace", &_inner_error_);
	_tmp2_ = _tmp1_;
	_g_free0 (_tmp2_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch0_g_io_error;
		}
		_g_object_unref0 (u);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	goto __finally0;
	__catch0_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		main_window_show_error (self, e->message);
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (u);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (u);
}


void main_window_on_stop (MainWindow* self) {
	Unit* _tmp0_ = NULL;
	Unit* u;
	char* _tmp1_ = NULL;
	char* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = main_window_get_current_unit (self);
	u = _tmp0_;
	if (u == NULL) {
		_g_object_unref0 (u);
		return;
	}
	_tmp1_ = unit_stop (u, "replace", &_inner_error_);
	_tmp2_ = _tmp1_;
	_g_free0 (_tmp2_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch1_g_io_error;
		}
		_g_object_unref0 (u);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	goto __finally1;
	__catch1_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		main_window_show_error (self, e->message);
		_g_error_free0 (e);
	}
	__finally1:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (u);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (u);
}


void main_window_on_reload (MainWindow* self) {
	Unit* _tmp0_ = NULL;
	Unit* u;
	char* _tmp1_ = NULL;
	char* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = main_window_get_current_unit (self);
	u = _tmp0_;
	if (u == NULL) {
		_g_object_unref0 (u);
		return;
	}
	_tmp1_ = unit_reload (u, "replace", &_inner_error_);
	_tmp2_ = _tmp1_;
	_g_free0 (_tmp2_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch2_g_io_error;
		}
		_g_object_unref0 (u);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	goto __finally2;
	__catch2_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		main_window_show_error (self, e->message);
		_g_error_free0 (e);
	}
	__finally2:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (u);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (u);
}


void main_window_on_restart (MainWindow* self) {
	Unit* _tmp0_ = NULL;
	Unit* u;
	char* _tmp1_ = NULL;
	char* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = main_window_get_current_unit (self);
	u = _tmp0_;
	if (u == NULL) {
		_g_object_unref0 (u);
		return;
	}
	_tmp1_ = unit_restart (u, "replace", &_inner_error_);
	_tmp2_ = _tmp1_;
	_g_free0 (_tmp2_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch3_g_io_error;
		}
		_g_object_unref0 (u);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	goto __finally3;
	__catch3_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		main_window_show_error (self, e->message);
		_g_error_free0 (e);
	}
	__finally3:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (u);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (u);
}


void main_window_on_cancel (MainWindow* self) {
	Job* _tmp0_ = NULL;
	Job* j;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = main_window_get_current_job (self);
	j = _tmp0_;
	if (j == NULL) {
		_g_object_unref0 (j);
		return;
	}
	job_cancel (j, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch4_g_io_error;
		}
		_g_object_unref0 (j);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	goto __finally4;
	__catch4_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		main_window_show_error (self, e->message);
		_g_error_free0 (e);
	}
	__finally4:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (j);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (j);
}


void main_window_update_unit_iter (MainWindow* self, GtkTreeIter* iter, const gchar* id, Unit* u) {
	gchar* _tmp0_;
	gchar* t;
	UnitJobLink _tmp1_ = {0};
	UnitJobLink jl;
	gchar* _tmp6_ = NULL;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_;
	gchar* _tmp13_ = NULL;
	gchar* _tmp14_;
	gchar* _tmp15_ = NULL;
	gchar* _tmp16_;
	gchar* _tmp17_ = NULL;
	gchar* _tmp18_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id != NULL);
	g_return_if_fail (u != NULL);
	_tmp0_ = g_strdup ("");
	t = _tmp0_;
	unit_get_job (u, &_tmp1_);
	jl = _tmp1_;
	if (jl.id != 0) {
		GBusType _tmp2_ = 0;
		Job* _tmp3_ = NULL;
		Job* j;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		if (user) {
			_tmp2_ = G_BUS_TYPE_SESSION;
		} else {
			_tmp2_ = G_BUS_TYPE_SYSTEM;
		}
		_tmp3_ = g_initable_new (TYPE_JOB_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "org.freedesktop.systemd1", "g-bus-type", _tmp2_, "g-object-path", (const gchar*) jl.path, "g-interface-name", "org.freedesktop.systemd1.Job", NULL);
		j = (Job*) _tmp3_;
		if (_inner_error_ != NULL) {
			unit_job_link_destroy (&jl);
			_g_free0 (t);
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch5_g_io_error;
			}
			unit_job_link_destroy (&jl);
			_g_free0 (t);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp4_ = job_get_job_type (j);
		_tmp5_ = _tmp4_;
		_g_free0 (t);
		t = _tmp5_;
		_g_object_unref0 (j);
	}
	if (g_strcmp0 (t, "") != 0) {
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		_tmp7_ = g_strdup_printf ("→ %s", t);
		_tmp8_ = _tmp7_;
		_g_free0 (_tmp6_);
		_tmp6_ = _tmp8_;
	} else {
		gchar* _tmp9_;
		gchar* _tmp10_;
		_tmp9_ = g_strdup ("");
		_tmp10_ = _tmp9_;
		_g_free0 (_tmp6_);
		_tmp6_ = _tmp10_;
	}
	_tmp11_ = unit_get_description (u);
	_tmp12_ = _tmp11_;
	_tmp13_ = unit_get_load_state (u);
	_tmp14_ = _tmp13_;
	_tmp15_ = unit_get_active_state (u);
	_tmp16_ = _tmp15_;
	_tmp17_ = unit_get_sub_state (u);
	_tmp18_ = _tmp17_;
	gtk_list_store_set (self->priv->unit_model, iter, 0, id, 1, _tmp12_, 2, _tmp14_, 3, _tmp16_, 4, _tmp18_, 5, _tmp6_, 6, u, -1);
	_g_free0 (_tmp18_);
	_g_free0 (_tmp16_);
	_g_free0 (_tmp14_);
	_g_free0 (_tmp12_);
	_g_free0 (_tmp6_);
	unit_job_link_destroy (&jl);
	_g_free0 (t);
	goto __finally5;
	__catch5_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		main_window_show_error (self, e->message);
		_g_error_free0 (e);
	}
	__finally5:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


void main_window_on_unit_new (MainWindow* self, const gchar* id, const char* path) {
	GBusType _tmp0_ = 0;
	Properties* _tmp1_ = NULL;
	Properties* p;
	GtkTreeIter iter = {0};
	GtkTreeIter _tmp2_ = {0};
	GBusType _tmp3_ = 0;
	Unit* _tmp4_ = NULL;
	Unit* u;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id != NULL);
	g_return_if_fail (path != NULL);
	if (user) {
		_tmp0_ = G_BUS_TYPE_SESSION;
	} else {
		_tmp0_ = G_BUS_TYPE_SYSTEM;
	}
	_tmp1_ = g_initable_new (TYPE_PROPERTIES_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "org.freedesktop.systemd1", "g-bus-type", _tmp0_, "g-object-path", (const gchar*) path, "g-interface-name", "org.freedesktop.Properties", NULL);
	p = (Properties*) _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch6_g_io_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	g_signal_connect_object (p, "properties-changed", (GCallback) _main_window_on_unit_changed_properties_properties_changed, self, 0);
	gtk_list_store_append (self->priv->unit_model, &_tmp2_);
	iter = _tmp2_;
	if (user) {
		_tmp3_ = G_BUS_TYPE_SESSION;
	} else {
		_tmp3_ = G_BUS_TYPE_SYSTEM;
	}
	_tmp4_ = g_initable_new (TYPE_UNIT_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "org.freedesktop.systemd1", "g-bus-type", _tmp3_, "g-object-path", (const gchar*) path, "g-interface-name", "org.freedesktop.systemd1.Unit", NULL);
	u = (Unit*) _tmp4_;
	if (_inner_error_ != NULL) {
		_g_object_unref0 (p);
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch6_g_io_error;
		}
		_g_object_unref0 (p);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	main_window_update_unit_iter (self, &iter, id, u);
	_g_object_unref0 (u);
	_g_object_unref0 (p);
	goto __finally6;
	__catch6_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		main_window_show_error (self, e->message);
		_g_error_free0 (e);
	}
	__finally6:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


void main_window_update_job_iter (MainWindow* self, GtkTreeIter* iter, guint32 id, Job* j) {
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	JobUnitLink _tmp2_ = {0};
	JobUnitLink _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (j != NULL);
	_tmp0_ = g_strdup_printf ("%u", (guint) id);
	_tmp1_ = _tmp0_;
	job_get_unit (j, &_tmp2_);
	_tmp3_ = _tmp2_;
	_tmp4_ = job_get_job_type (j);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_strdup_printf ("→ %s", _tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = job_get_state (j);
	_tmp9_ = _tmp8_;
	gtk_list_store_set (self->priv->job_model, iter, 0, _tmp1_, 1, _tmp3_.id, 2, _tmp7_, 3, _tmp9_, 4, j, 5, id, -1);
	_g_free0 (_tmp9_);
	_g_free0 (_tmp7_);
	_g_free0 (_tmp5_);
	job_unit_link_destroy (&_tmp3_);
	_g_free0 (_tmp1_);
}


void main_window_on_job_new (MainWindow* self, guint32 id, const char* path) {
	GBusType _tmp0_ = 0;
	Properties* _tmp1_ = NULL;
	Properties* p;
	GtkTreeIter iter = {0};
	GtkTreeIter _tmp2_ = {0};
	GBusType _tmp3_ = 0;
	Job* _tmp4_ = NULL;
	Job* j;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	if (user) {
		_tmp0_ = G_BUS_TYPE_SESSION;
	} else {
		_tmp0_ = G_BUS_TYPE_SYSTEM;
	}
	_tmp1_ = g_initable_new (TYPE_PROPERTIES_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "org.freedesktop.systemd1", "g-bus-type", _tmp0_, "g-object-path", (const gchar*) path, "g-interface-name", "org.freedesktop.Properties", NULL);
	p = (Properties*) _tmp1_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch7_g_io_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	g_signal_connect_object (p, "properties-changed", (GCallback) _main_window_on_job_changed_properties_properties_changed, self, 0);
	gtk_list_store_append (self->priv->job_model, &_tmp2_);
	iter = _tmp2_;
	if (user) {
		_tmp3_ = G_BUS_TYPE_SESSION;
	} else {
		_tmp3_ = G_BUS_TYPE_SYSTEM;
	}
	_tmp4_ = g_initable_new (TYPE_JOB_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "org.freedesktop.systemd1", "g-bus-type", _tmp3_, "g-object-path", (const gchar*) path, "g-interface-name", "org.freedesktop.systemd1.Job", NULL);
	j = (Job*) _tmp4_;
	if (_inner_error_ != NULL) {
		_g_object_unref0 (p);
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch7_g_io_error;
		}
		_g_object_unref0 (p);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	main_window_update_job_iter (self, &iter, id, j);
	_g_object_unref0 (j);
	_g_object_unref0 (p);
	goto __finally7;
	__catch7_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		main_window_show_error (self, e->message);
		_g_error_free0 (e);
	}
	__finally7:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


void main_window_on_unit_removed (MainWindow* self, const gchar* id, const char* path) {
	GtkTreeIter iter = {0};
	GtkTreeIter _tmp0_ = {0};
	gboolean _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id != NULL);
	g_return_if_fail (path != NULL);
	_tmp1_ = gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->unit_model, &_tmp0_);
	iter = _tmp0_;
	if (!_tmp1_) {
		return;
	}
	{
		gboolean _tmp2_;
		_tmp2_ = TRUE;
		while (TRUE) {
			gchar* name = NULL;
			if (!_tmp2_) {
				gboolean _tmp3_;
				_tmp3_ = gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->unit_model, &iter);
				if (!_tmp3_) {
					break;
				}
			}
			_tmp2_ = FALSE;
			gtk_tree_model_get ((GtkTreeModel*) self->priv->unit_model, &iter, 0, &name, -1);
			if (g_strcmp0 (id, name) == 0) {
				if (g_strcmp0 (self->priv->current_unit_id, name) == 0) {
					main_window_clear_unit (self);
				}
				gtk_list_store_remove (self->priv->unit_model, &iter);
				_g_free0 (name);
				break;
			}
			_g_free0 (name);
		}
	}
}


void main_window_on_job_removed (MainWindow* self, guint32 id, const char* path, const gchar* res) {
	GtkTreeIter iter = {0};
	GtkTreeIter _tmp0_ = {0};
	gboolean _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	g_return_if_fail (res != NULL);
	_tmp1_ = gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->job_model, &_tmp0_);
	iter = _tmp0_;
	if (!_tmp1_) {
		return;
	}
	{
		gboolean _tmp2_;
		_tmp2_ = TRUE;
		while (TRUE) {
			guint32 j = 0U;
			if (!_tmp2_) {
				gboolean _tmp3_;
				_tmp3_ = gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->job_model, &iter);
				if (!_tmp3_) {
					break;
				}
			}
			_tmp2_ = FALSE;
			gtk_tree_model_get ((GtkTreeModel*) self->priv->job_model, &iter, 5, &j, -1);
			if (id == j) {
				if (self->priv->current_job_id == j) {
					main_window_clear_job (self);
				}
				gtk_list_store_remove (self->priv->job_model, &iter);
				break;
			}
		}
	}
}


void main_window_on_unit_changed (MainWindow* self, Properties* p, const gchar* iface, GHashTable* changed_properties, gchar** invalidated_properties, int invalidated_properties_length1) {
	GtkTreeIter iter = {0};
	gchar* id = NULL;
	GBusType _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	Unit* _tmp5_ = NULL;
	Unit* u;
	GtkTreeIter _tmp6_ = {0};
	gboolean _tmp7_;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (p != NULL);
	g_return_if_fail (iface != NULL);
	g_return_if_fail (changed_properties != NULL);
	if (user) {
		_tmp0_ = G_BUS_TYPE_SESSION;
	} else {
		_tmp0_ = G_BUS_TYPE_SYSTEM;
	}
	_tmp1_ = g_dbus_proxy_get_name ((GDBusProxy*) p);
	_tmp2_ = g_dbus_proxy_get_object_path ((GDBusProxy*) p);
	_tmp3_ = g_dbus_proxy_get_name ((GDBusProxy*) p);
	_tmp4_ = g_dbus_proxy_get_object_path ((GDBusProxy*) p);
	_tmp5_ = g_initable_new (TYPE_UNIT_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", _tmp3_, "g-bus-type", _tmp0_, "g-object-path", _tmp4_, "g-interface-name", "org.freedesktop.systemd1.Unit", NULL);
	u = (Unit*) _tmp5_;
	if (_inner_error_ != NULL) {
		_g_free0 (id);
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch8_g_io_error;
		}
		_g_free0 (id);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp7_ = gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->unit_model, &_tmp6_);
	iter = _tmp6_;
	if (!_tmp7_) {
		_g_object_unref0 (u);
		_g_free0 (id);
		return;
	}
	_tmp8_ = unit_get_id (u);
	_tmp9_ = _tmp8_;
	_g_free0 (id);
	id = _tmp9_;
	{
		gboolean _tmp10_;
		_tmp10_ = TRUE;
		while (TRUE) {
			gchar* name = NULL;
			if (!_tmp10_) {
				gboolean _tmp11_;
				_tmp11_ = gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->unit_model, &iter);
				if (!_tmp11_) {
					break;
				}
			}
			_tmp10_ = FALSE;
			gtk_tree_model_get ((GtkTreeModel*) self->priv->unit_model, &iter, 0, &name, -1);
			if (g_strcmp0 (id, name) == 0) {
				main_window_update_unit_iter (self, &iter, id, u);
				if (g_strcmp0 (self->priv->current_unit_id, id) == 0) {
					main_window_show_unit (self, u);
				}
				_g_free0 (name);
				break;
			}
			_g_free0 (name);
		}
	}
	_g_object_unref0 (u);
	_g_free0 (id);
	goto __finally8;
	__catch8_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		main_window_show_error (self, e->message);
		_g_error_free0 (e);
	}
	__finally8:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


void main_window_on_job_changed (MainWindow* self, Properties* p, const gchar* iface, GHashTable* changed_properties, gchar** invalidated_properties, int invalidated_properties_length1) {
	GtkTreeIter iter = {0};
	guint32 id = 0U;
	GBusType _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	Job* _tmp5_ = NULL;
	Job* j;
	GtkTreeIter _tmp6_ = {0};
	gboolean _tmp7_;
	guint32 _tmp8_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (p != NULL);
	g_return_if_fail (iface != NULL);
	g_return_if_fail (changed_properties != NULL);
	if (user) {
		_tmp0_ = G_BUS_TYPE_SESSION;
	} else {
		_tmp0_ = G_BUS_TYPE_SYSTEM;
	}
	_tmp1_ = g_dbus_proxy_get_name ((GDBusProxy*) p);
	_tmp2_ = g_dbus_proxy_get_object_path ((GDBusProxy*) p);
	_tmp3_ = g_dbus_proxy_get_name ((GDBusProxy*) p);
	_tmp4_ = g_dbus_proxy_get_object_path ((GDBusProxy*) p);
	_tmp5_ = g_initable_new (TYPE_JOB_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", _tmp3_, "g-bus-type", _tmp0_, "g-object-path", _tmp4_, "g-interface-name", "org.freedesktop.systemd1.Job", NULL);
	j = (Job*) _tmp5_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch9_g_io_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp7_ = gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->job_model, &_tmp6_);
	iter = _tmp6_;
	if (!_tmp7_) {
		_g_object_unref0 (j);
		return;
	}
	_tmp8_ = job_get_id (j);
	id = _tmp8_;
	{
		gboolean _tmp9_;
		_tmp9_ = TRUE;
		while (TRUE) {
			guint32 k = 0U;
			if (!_tmp9_) {
				gboolean _tmp10_;
				_tmp10_ = gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->job_model, &iter);
				if (!_tmp10_) {
					break;
				}
			}
			_tmp9_ = FALSE;
			gtk_tree_model_get ((GtkTreeModel*) self->priv->job_model, &iter, 5, &k, -1);
			if (id == k) {
				main_window_update_job_iter (self, &iter, id, j);
				if (self->priv->current_job_id == id) {
					main_window_show_job (self, j);
				}
				break;
			}
		}
	}
	_g_object_unref0 (j);
	goto __finally9;
	__catch9_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		main_window_show_error (self, e->message);
		_g_error_free0 (e);
	}
	__finally9:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


gboolean main_window_unit_filter (MainWindow* self, GtkTreeModel* model, GtkTreeIter* iter) {
	gboolean result = FALSE;
	gchar* id = NULL;
	gchar* active_state = NULL;
	gchar* job = NULL;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (model != NULL, FALSE);
	gtk_tree_model_get (model, iter, 0, &id, 3, &active_state, 5, &job, -1);
	if (id == NULL) {
		result = FALSE;
		_g_free0 (job);
		_g_free0 (active_state);
		_g_free0 (id);
		return result;
	}
	_tmp0_ = gtk_combo_box_get_active (self->priv->unit_type_combo_box);
	switch (_tmp0_) {
		case 0:
		{
			result = TRUE;
			_g_free0 (job);
			_g_free0 (active_state);
			_g_free0 (id);
			return result;
		}
		case 1:
		{
			gboolean _tmp1_ = FALSE;
			if (g_strcmp0 (active_state, "inactive") != 0) {
				_tmp1_ = TRUE;
			} else {
				_tmp1_ = g_strcmp0 (job, "") != 0;
			}
			result = _tmp1_;
			_g_free0 (job);
			_g_free0 (active_state);
			_g_free0 (id);
			return result;
		}
		case 2:
		{
			gboolean _tmp2_;
			_tmp2_ = g_str_has_suffix (id, ".service");
			result = _tmp2_;
			_g_free0 (job);
			_g_free0 (active_state);
			_g_free0 (id);
			return result;
		}
		case 3:
		{
			gboolean _tmp3_;
			_tmp3_ = g_str_has_suffix (id, ".socket");
			result = _tmp3_;
			_g_free0 (job);
			_g_free0 (active_state);
			_g_free0 (id);
			return result;
		}
		case 4:
		{
			gboolean _tmp4_;
			_tmp4_ = g_str_has_suffix (id, ".device");
			result = _tmp4_;
			_g_free0 (job);
			_g_free0 (active_state);
			_g_free0 (id);
			return result;
		}
		case 5:
		{
			gboolean _tmp5_;
			_tmp5_ = g_str_has_suffix (id, ".mount");
			result = _tmp5_;
			_g_free0 (job);
			_g_free0 (active_state);
			_g_free0 (id);
			return result;
		}
		case 6:
		{
			gboolean _tmp6_;
			_tmp6_ = g_str_has_suffix (id, ".automount");
			result = _tmp6_;
			_g_free0 (job);
			_g_free0 (active_state);
			_g_free0 (id);
			return result;
		}
		case 7:
		{
			gboolean _tmp7_;
			_tmp7_ = g_str_has_suffix (id, ".target");
			result = _tmp7_;
			_g_free0 (job);
			_g_free0 (active_state);
			_g_free0 (id);
			return result;
		}
		case 8:
		{
			gboolean _tmp8_;
			_tmp8_ = g_str_has_suffix (id, ".snapshot");
			result = _tmp8_;
			_g_free0 (job);
			_g_free0 (active_state);
			_g_free0 (id);
			return result;
		}
		default:
		break;
	}
	result = FALSE;
	_g_free0 (job);
	_g_free0 (active_state);
	_g_free0 (id);
	return result;
}


void main_window_unit_type_changed (MainWindow* self) {
	GtkTreeModel* _tmp0_ = NULL;
	GtkTreeModelFilter* _tmp1_;
	GtkTreeModelFilter* model;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_tree_view_get_model (self->priv->unit_view);
	_tmp1_ = _g_object_ref0 (GTK_TREE_MODEL_FILTER (_tmp0_));
	model = _tmp1_;
	gtk_tree_model_filter_refilter (model);
	_g_object_unref0 (model);
}


void main_window_on_server_reload (MainWindow* self) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	manager_reload (self->priv->manager, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch10_g_io_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	goto __finally10;
	__catch10_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		main_window_show_error (self, e->message);
		_g_error_free0 (e);
	}
	__finally10:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


void main_window_on_server_snapshot (MainWindow* self) {
	char* _tmp0_ = NULL;
	char* _tmp1_;
	gint _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = manager_create_snapshot (self->priv->manager, "", FALSE, &_inner_error_);
	_tmp1_ = _tmp0_;
	_g_free0 (_tmp1_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch11_g_io_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp2_ = gtk_combo_box_get_active (self->priv->unit_type_combo_box);
	if (_tmp2_ != 0) {
		gtk_combo_box_set_active (self->priv->unit_type_combo_box, 8);
	}
	goto __finally11;
	__catch11_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		main_window_show_error (self, e->message);
		_g_error_free0 (e);
	}
	__finally11:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


void main_window_on_unit_load (MainWindow* self) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* t;
	char* _tmp2_ = NULL;
	char* path;
	GBusType _tmp3_ = 0;
	Unit* _tmp4_ = NULL;
	Unit* u;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	GtkMessageDialog* _tmp7_ = NULL;
	GtkMessageDialog* _tmp8_;
	GtkMessageDialog* m;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_entry_get_text (self->priv->unit_load_entry);
	_tmp1_ = g_strdup (_tmp0_);
	t = _tmp1_;
	if (g_strcmp0 (t, "") == 0) {
		_g_free0 (t);
		return;
	}
	_tmp2_ = manager_load_unit (self->priv->manager, t, &_inner_error_);
	path = _tmp2_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch12_g_io_error;
		}
		_g_free0 (t);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	if (user) {
		_tmp3_ = G_BUS_TYPE_SESSION;
	} else {
		_tmp3_ = G_BUS_TYPE_SYSTEM;
	}
	_tmp4_ = g_initable_new (TYPE_UNIT_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "org.freedesktop.systemd1", "g-bus-type", _tmp3_, "g-object-path", (const gchar*) path, "g-interface-name", "org.freedesktop.systemd1.Unit", NULL);
	u = (Unit*) _tmp4_;
	if (_inner_error_ != NULL) {
		_g_free0 (path);
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch12_g_io_error;
		}
		_g_free0 (path);
		_g_free0 (t);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp5_ = unit_get_id (u);
	_tmp6_ = _tmp5_;
	_tmp7_ = (GtkMessageDialog*) gtk_message_dialog_new ((GtkWindow*) self, GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_INFO, GTK_BUTTONS_CLOSE, "Unit available as id %s", _tmp6_);
	m = (_tmp8_ = g_object_ref_sink (_tmp7_), _g_free0 (_tmp6_), _tmp8_);
	gtk_window_set_title ((GtkWindow*) m, "Unit");
	gtk_dialog_run ((GtkDialog*) m);
	gtk_object_destroy ((GtkObject*) m);
	main_window_show_unit (self, u);
	_g_object_unref0 (m);
	_g_object_unref0 (u);
	_g_free0 (path);
	goto __finally12;
	__catch12_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		main_window_show_error (self, e->message);
		_g_error_free0 (e);
	}
	__finally12:
	if (_inner_error_ != NULL) {
		_g_free0 (t);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_free0 (t);
}


void main_window_on_unit_load_entry_changed (MainWindow* self) {
	const gchar* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_entry_get_text (self->priv->unit_load_entry);
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->unit_load_button, g_strcmp0 (_tmp0_, "") != 0);
}


gboolean main_window_on_activate_link (MainWindow* self, const gchar* uri) {
	gboolean result = FALSE;
	char* _tmp0_ = NULL;
	gchar* path;
	GBusType _tmp1_ = 0;
	Unit* _tmp2_ = NULL;
	Unit* u;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (uri != NULL, FALSE);
	_tmp0_ = manager_get_unit (self->priv->manager, uri, &_inner_error_);
	path = (gchar*) _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch13_g_io_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	if (user) {
		_tmp1_ = G_BUS_TYPE_SESSION;
	} else {
		_tmp1_ = G_BUS_TYPE_SYSTEM;
	}
	_tmp2_ = g_initable_new (TYPE_UNIT_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "org.freedesktop.systemd1", "g-bus-type", _tmp1_, "g-object-path", path, "g-interface-name", "org.freedesktop.systemd1.Unit", NULL);
	u = (Unit*) _tmp2_;
	if (_inner_error_ != NULL) {
		_g_free0 (path);
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch13_g_io_error;
		}
		_g_free0 (path);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	main_window_show_unit (self, u);
	_g_object_unref0 (u);
	_g_free0 (path);
	goto __finally13;
	__catch13_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		main_window_show_error (self, e->message);
		_g_error_free0 (e);
	}
	__finally13:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = TRUE;
	return result;
}


void main_window_show_error (MainWindow* self, const gchar* e) {
	GtkMessageDialog* _tmp0_ = NULL;
	GtkMessageDialog* m;
	g_return_if_fail (self != NULL);
	g_return_if_fail (e != NULL);
	_tmp0_ = (GtkMessageDialog*) gtk_message_dialog_new ((GtkWindow*) self, GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_ERROR, GTK_BUTTONS_CLOSE, "%s", e);
	m = g_object_ref_sink (_tmp0_);
	gtk_window_set_title ((GtkWindow*) m, "Error");
	gtk_dialog_run ((GtkDialog*) m);
	gtk_object_destroy ((GtkObject*) m);
	_g_object_unref0 (m);
}


static void main_window_class_init (MainWindowClass * klass) {
	main_window_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (MainWindowPrivate));
	G_OBJECT_CLASS (klass)->finalize = main_window_finalize;
}


static void main_window_instance_init (MainWindow * self) {
	self->priv = MAIN_WINDOW_GET_PRIVATE (self);
}


static void main_window_finalize (GObject* obj) {
	MainWindow * self;
	self = MAIN_WINDOW (obj);
	_g_free0 (self->priv->current_unit_id);
	_g_object_unref0 (self->priv->unit_view);
	_g_object_unref0 (self->priv->job_view);
	_g_object_unref0 (self->priv->unit_model);
	_g_object_unref0 (self->priv->job_model);
	_g_object_unref0 (self->priv->start_button);
	_g_object_unref0 (self->priv->stop_button);
	_g_object_unref0 (self->priv->restart_button);
	_g_object_unref0 (self->priv->reload_button);
	_g_object_unref0 (self->priv->cancel_button);
	_g_object_unref0 (self->priv->unit_load_entry);
	_g_object_unref0 (self->priv->unit_load_button);
	_g_object_unref0 (self->priv->server_snapshot_button);
	_g_object_unref0 (self->priv->server_reload_button);
	_g_object_unref0 (self->priv->manager);
	_g_object_unref0 (self->priv->unit_id_label);
	_g_object_unref0 (self->priv->unit_aliases_label);
	_g_object_unref0 (self->priv->unit_dependency_label);
	_g_object_unref0 (self->priv->unit_description_label);
	_g_object_unref0 (self->priv->unit_load_state_label);
	_g_object_unref0 (self->priv->unit_active_state_label);
	_g_object_unref0 (self->priv->unit_sub_state_label);
	_g_object_unref0 (self->priv->unit_fragment_path_label);
	_g_object_unref0 (self->priv->unit_active_enter_timestamp_label);
	_g_object_unref0 (self->priv->unit_active_exit_timestamp_label);
	_g_object_unref0 (self->priv->unit_can_start_label);
	_g_object_unref0 (self->priv->unit_can_reload_label);
	_g_object_unref0 (self->priv->unit_cgroup_label);
	_g_object_unref0 (self->priv->job_id_label);
	_g_object_unref0 (self->priv->job_state_label);
	_g_object_unref0 (self->priv->job_type_label);
	_g_object_unref0 (self->priv->unit_type_combo_box);
	G_OBJECT_CLASS (main_window_parent_class)->finalize (obj);
}


GType main_window_get_type (void) {
	static volatile gsize main_window_type_id__volatile = 0;
	if (g_once_init_enter (&main_window_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MainWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) main_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MainWindow), 0, (GInstanceInitFunc) main_window_instance_init, NULL };
		GType main_window_type_id;
		main_window_type_id = g_type_register_static (GTK_TYPE_WINDOW, "MainWindow", &g_define_type_info, 0);
		g_once_init_leave (&main_window_type_id__volatile, main_window_type_id);
	}
	return main_window_type_id__volatile;
}


void show_error (const gchar* e) {
	GtkMessageDialog* _tmp0_ = NULL;
	GtkMessageDialog* m;
	g_return_if_fail (e != NULL);
	_tmp0_ = (GtkMessageDialog*) gtk_message_dialog_new (NULL, 0, GTK_MESSAGE_ERROR, GTK_BUTTONS_CLOSE, "%s", e);
	m = g_object_ref_sink (_tmp0_);
	gtk_dialog_run ((GtkDialog*) m);
	gtk_object_destroy ((GtkObject*) m);
	_g_object_unref0 (m);
}


gint _vala_main (gchar** args, int args_length1) {
	gint result = 0;
	MainWindow* _tmp0_ = NULL;
	MainWindow* window;
	GError * _inner_error_ = NULL;
	gtk_init_with_args (&args_length1, &args, "[OPTION...]", entries, "systemadm", &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch14_g_io_error;
		}
		goto __catch14_g_error;
	}
	_tmp0_ = main_window_new (&_inner_error_);
	window = g_object_ref_sink (_tmp0_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_IO_ERROR) {
			goto __catch14_g_io_error;
		}
		goto __catch14_g_error;
	}
	gtk_widget_show_all ((GtkWidget*) window);
	gtk_main ();
	_g_object_unref0 (window);
	goto __finally14;
	__catch14_g_io_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		show_error (e->message);
		_g_error_free0 (e);
	}
	goto __finally14;
	__catch14_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		show_error (e->message);
		_g_error_free0 (e);
	}
	__finally14:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	result = 0;
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return _vala_main (argv, argc);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



